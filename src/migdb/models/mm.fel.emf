@namespace(uri="http://www.collectionspro.eu/jam/mm", prefix="mm")
package mm;


@namespace(uri="http://www.collectionspro.eu/jam/mm/reduced-jam", prefix="reduced")
package reduced {

	class ModelRoot {
		val Model[1] sourceModel;
		val Model[0..1] targetModel;
		ordered val ModelOperation[*]#modelRoot operations;
	}

	class Model {
		!ordered val Class[*]#owningModel classes;		
	}
	
	abstract class ModelOperation {
		derived readonly ref ModelRoot[1]#operations modelRoot;			
	}

	abstract class NamedElement {
		attr String[1] name;
	}

	class Class extends NamedElement {
		derived readonly ref Model[1]#classes owningModel;
		
		ref Class[0..1] parent;	
		attr boolean isPrimitive = false;
		!ordered val Property[*]#owningClass properties;
		
		val ClassSerialization[0..1] classSerialization;
	}
	
	// singleTable: All classes in the tree hierarchy is persiseted to one common table
	// tablePerClass: Indepenedent table for each class - DO NOT SUPPORT
	// joined: Each class int the hierarchy has its own table for owned value attributes 
	enum InheritanceType {
		__not_defined;
		singleTable;	
		tablePerClass;
		joined;
	}

	enum ReferenceType {
		__not_defined;
		basic;
		oneToOne;
		manyToOne;
		oneToMany;
	}
	
	
	class ClassSerialization {
		// If true, all other attributes are meaningless and the class is not serialized at all
		attr boolean[1] isTransient = false;

		// The class is embedded, so it always persisted in context of owning class 
		attr boolean[1] isEmbedded = false;

		// Name of table overriding the default name
		attr String[0..1] tableName; 
		attr InheritanceType[1] inheritanceType;
		
		//ref kernel.Property[0..1] primaryKeyJoinColumn;
	}
	
	class Property extends NamedElement {
		derived readonly ref Class[1]#properties owningClass;
		
		val PropertySerialization[0..1] serialization;
		ref Class[1] type;
		ref Property[0..1] opositeProperty;
		
		// Multiplicity specification
		// -1 means *
		attr int lowerBound = 0;
		attr int upperBound = 1;
		// For upper bound > 1 or *
		attr boolean isUnique = false;
		attr boolean isOrdered = false;
		
		// Do not use yet
		// attr ReferenceType[0..1] referenceType;
	}
	
	class PropertySerialization {
		// If true, this property should not be serialized
		attr boolean[1] isTransient = false;

		// true for all properties of embedded class, false otherwise
		attr boolean[1] isEmbedded = false;
		// if isEmbedded then column name for the property is computed by the pattern 
		attr String[0..1] columnNamePattern;

		// true if the property holds unique identificator of owner class' instances 
		// each serialized class has to have 1! property with isID = true
		attr boolean[1] isID = false;
		// name of sequence for 
		attr String[0..1] sequenceName;
		// if specified, overrides dedfault derived column name
		attr String[0..1] columnName;
		
		// Do not use yet
		// attr String[0..1] indexColumnName;
		// attr String[0..1] joinColumnName;
	}
}

@namespace(uri="http://www.collectionspro.eu/jam/mm/rdb", prefix="mmrdb")
package rdb {
	
	class ModelRoot {
		val Database[1] sourceDB;
		val Database[1] targetDB;
		ordered val Operation[0..*]#modelRoot operations;
	} 
	
	class Database extends reduced.NamedElement {
		!ordered val Schema[*] schemas;
	}
	
	abstract class DbObject extends reduced.NamedElement {
	}
	
	class Schema extends DbObject {
		
		!ordered val Table[*]#owningSchema tables;
		
		!ordered val Sequence[*]#owningSchema sequences;

		!ordered val Index[*]#owningSchema indexes;
	}
	
	@OCL (inv= "self.primaryKey->notEmpty() implies in self.indexes->contains(self.primaryKey)")
	abstract class Relation {

		// Implemented in subclasses
		!ordered op Column[*] getColumns();
	}

	@OCL (inv= "self.primaryKey->notEmpty() implies in self.indexes->contains(self.primaryKey)")
	class Table extends DbObject, Relation {
	
		derived readonly ref Schema[1]#tables owningSchema;
	
		ref PrimaryKey[0..1] primaryKey;
		
		@OCL (body="if self.primaryKey->isEmpty() then
						null
					else
						self.primaryKey.underlyingIndex.columns->first()
					endif
					")
		op Column[0..1] getPrimaryColumn();
	
		!ordered val TableColumn[*]#_owningTable ownedColumns;
	
		!ordered val TableConstraint[*]#owningTable constraints;

		// Op from Relation
		!ordered op Column[*] getColumns();
	}
	
	class Sequence extends DbObject {
		derived readonly ref Schema[1]#sequences owningSchema;
		attr int cacheSize;
	}
	
	abstract class Constraint extends DbObject {
		
	}
	
	abstract class TableConstraint extends Constraint, reduced.NamedElement {
		derived readonly ref Table[1]#constraints owningTable;	   
	}
	
	abstract class ColumnConstraint extends Constraint {
		derived readonly ref TableColumn[1]#constraints owningColumn;
	}
	
	@OCL(inv="self.constrainedColumn.owningTable = self.targetTable)")
	@OCL(inv="self.targetTable.getPrimaryColumn()->notEmpty()")
	class ForeignKey extends TableConstraint {
		ref Table[1] targetTable;
		ref TableColumn[1] constrainedColumn;
	}
	
	abstract class Column extends reduced.NamedElement {
	
		// Implemented in subclasses
		op Table getOwningTable();
	}
	
	class TableColumn extends Column {
		derived readonly ref Table[1]#ownedColumns _owningTable;
		
		!ordered val ColumnConstraint[*]#owningColumn constraints;
		
		@OCL(body="self._owningTable")
		op Table getOwningTable();
	}
	
	@OCL(inv="let first : TableColumn = self.columnsMap->first() in
			  self.columns->forAll(col | col._owningTable = first._owningTable)")
	class Index extends DbObject {
		
		//Upraveno jako neusporadana mnozina (z 19.10.)
		!ordered ref TableColumn[1..*] columns;
		
		@OCL(drv ="self.columns->first()._owningTable")
		transient derived readonly volatile 
			ref Table[1] indexedTable;
		
		derived readonly ref Schema[1]#indexes owningSchema;
	}
	
	@OCL(inv= "self.owningTable = self.underlyingIndex.indexedTable")
	class UniqueIndex extends TableConstraint {
		ref Index[1] underlyingIndex; 
	}

	@OCL(inv= "self.underlyingIndex.columns.size() = 1")
	class PrimaryKey extends UniqueIndex {
	}
		
	abstract class Operation {
		derived readonly ref ModelRoot[1]#operations modelRoot;
	}
	
	class CreateTable extends Operation {
	   attr String tableName;
	   
	   !ordered ref TableColumn[*] tableColumns;
	   !ordered ref TableConstraint[*] tableConstraints;
	   ref PrimaryKey[0..1] primaryKey;
	   readonly ref Sequence[1] generateID;
	   
	   // Q:(Pavel) Co by ta operace mela delat? A vsechy analogicke v dalsich tridach.
	   op boolean createTable(String tableName, TableColumn[*] tableColumns,
	   						  TableConstraint[*] tableConstraints,
	   						  PrimaryKey[0..1] primaryKey, Sequence[1] generateID);
	}
	
	class RenameTable extends Operation {
	   ref Table[1] renamedTable;
	   attr String newName;
	   
	   op boolean renameTable(String newName, Table renamedTable);
	}
	
	class DeleteTable extends Operation {
		ref Table[1] deletedTable;
		
		op boolean deleteTable(Table deletedTable);		   
	}
	
	class AddColumn extends Operation {
	   attr String newColumnName;
	   ref Table[1] changedTable;
	   !ordered ref ColumnConstraint[*] columnConstrains;
	   
	   op boolean addColumn(Table changedTable, String newColumnName,
	   						ColumnConstraint[*] columnConstrains);
	}
	
	class RenameColumn extends Operation {
	   attr String newColumnName;
	   ref Table[1] changedTable;
	   
	   @OCL(inv="self.owningTable = changedTable")
	   ref TableColumn[1] renamedColumn;
	   
	   op boolean renameColumn(String newColumnName, Table changedTable,
	   						   TableColumn renamedColumn);
	}
	
	class TypeChangeToColumn extends Operation {
	   attr String newType;
	   ref Table[1] changedTable;
	   
	   @OCL(inv="self.owningTable = changedTable")
	   ref TableColumn[1] changedTypeColumn;
	   
	   op boolean typeChangeToColumn(String newType, Table changedTable,
	   								 TableColumn changedTypeColumn);
	   
	}
	
	class DeleteColumn extends Operation {
	   ref Table[1] changedTable;
	   
	   @OCL(inv="self.owningTable = changedTable")
	   ref TableColumn[1] deleteColumn;
	   
	   op boolean deleteColumn(Table changedTable, TableColumn deleteColumn);
	}
	
	//A tady zatim koncime

@namespace(uri="http://www.collectionspro.eu/jam/mm/rdb-dml", prefix="mmrdb-dml")
package dml {
	class Query extends Relation {
		@DVU(subsets="self.columns")
		val ColumnReference[1..*] columnReferences;
		// ...
	}
	
	class ColumnReference extends Column {
		ref Column[1] reference;
	}
	
	/*
		... 
	*/
}

}