/*
 * The MIT License
 * 
 * Copyright (c) 2010 MigDB team [https://rabbit.felk.cvut.cz/trac/migdb]
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
 
modeltype APP uses 'mm-app';
modeltype RDB uses 'mm-db';

transformation Simpleuml_To_Rdb(in uml : APP, out RDB);

main() {
	log("zacatek transformace");
	uml.rootObjects()[APP::reduced::ModelRoot]->map toRdbRoot();
	log("konec transformace");
}

mapping APP::reduced::ModelRoot::toRdbRoot() : RDB::rdb::ModelRoot {
	log("toRdbRoot sekce");
	sourceDB := self.sourceModel.map toDBmodel();
}

mapping APP::reduced::Model::toDBmodel() : RDB::rdb::Database {
	log("toDBmodel sekce");
	schemas += self.map toSchema();
}

mapping APP::reduced::Model::toSchema() : RDB::rdb::Schema {
	log("toSchema sekce");
		
	self.classes->forEach(Class) {
		if(Class.isPrimitive = false) then {
			var table:RDB::rdb::Table:=Class.map toTable();
			tables += table;
		} endif;
	};
}


mapping APP::reduced::Class::toTable() : RDB::rdb::Table {
	log("toTables sekce "+self.name);
	name := self.name;
	
	//var parent:APP::reduced::Class = self.parent;
	//var table:RDB::rdb::Table ;
	//while(parent <> null){
		//table =
		// owningSchema.tables+=parent.map toTable();
			//};
			
	if(self.parent <> null)then{
		primaryKey:= self.map toAncestorId();
		constraints+=primaryKey;
		primaryKey.owningTable = result;		
	}endif;
	
	self.properties->forEach(Property) {
		if((Property.serialization = null or (Property.serialization.isTransient = false))) then {	
			var col: RDB::rdb::TableColumn = Property.map toColumn(); 
			ownedColumns += col;	
			
			if(Property.isID() = true) then {
				primaryKey:= col.map toPrimaryKey();	
		    	constraints+=primaryKey;
		    }endif;
		    
		    if(Property.isForeignKey() = true) then{
		    	var const : RDB::rdb::ForeignKey := Property.map toForeignKey();
	    		const.owningTable =result;
				result.constraints+=const;
		    }endif;		
		} endif;		
	};
	
}



mapping APP::reduced::Property::toColumn() : RDB::rdb::TableColumn {
	log("toColumn sekce");
	
	name = self.getName();
	if(self.type.isPrimitive = true) then {		
		switch {
			case (self.type.name = "String") {
				type:= "varchar";
			}
			case (self.type.name = "Int") {
				type := "number";
			}
			case (self.type.name = "Boolean") {
				//zatim boolean
				type := "boolean";
			}
			else {
				log("neznamy typ" + self.type.name);
			}
		}	
	} else {
		if(self.serialization.isID) then{
			type :="PK";
		} else{
		// jedna se o FK		
		type := "FK";
		} endif;
	} endif;
}

mapping RDB::rdb::TableColumn::toPrimaryKey() : RDB::rdb::PrimaryKey{
	log("toPrimaryKey mappovani");
	owningTable = self._owningTable;
	name := self.name+"_"+self._owningTable.name;
	self._owningTable.primaryKey=result;
	self._owningTable.constraints+=result;
	//underlyingIndex := 
}

mapping APP::reduced::Property::toForeignKey(): RDB::rdb::ForeignKey{
	result.name := "FK "+ self.name;
	log("toForeignKey sekce" + "  "+ self.name);
} 

//mapping toPK(s:Set(RDB::rdb::TableColumn),table:RDB::rdb::Table) : RDB::rdb::PrimaryKey{
//		log("vstupuju do PK mappovani");
//		s->forEach(tableCol){
//			underlyingIndex.columns+=tableCol;
//		};
//		//owningTable:= underlyingIndex.columns->first().;
//		owningTable = table;
//}

query APP::reduced::Class::isTransient() : Boolean {
	if (self.classSerialization->notEmpty()) then
		return self.classSerialization.isTransient
	endif;
	return false
}

query APP::reduced::Property::getName(): String{
	if(self.serialization = null or self.serialization.columnName = "") then {
		return self.name;
	} else {
		return self.serialization.columnName;
	} endif;
	return null;
}

query APP::reduced::Property::isForeignKey(): Boolean{
	log("v sekci isForeignKey ");
	
	if((self.type.isPrimitive = true) = false and (self.serialization.isID =true) = false) then {
		return true;
	} endif;
	return false;
}

mapping APP::reduced::Class::toAncestorId():RDB::rdb::PrimaryKey{
	log("toAncestorID");
	var temp:APP::reduced::Class := self;
	while((temp.parent = null)=false){
		temp:=temp.parent;
			};
	temp.properties->forEach(Property){
		if(Property.isID())then{
				result.name=Property.name;
				break;
			}endif;
	};
	//return null;
}

query APP::reduced::Property::isID():Boolean{
	if(self.serialization.isID = true) then {
		return true;
	}endif;
	return false;
}