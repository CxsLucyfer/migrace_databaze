modeltype __ecore uses "http://www.eclipse.org/emf/2002/Ecore";
modeltype mm uses "http://www.collectionspro.eu/jam/mm";
modeltype utils uses "http://www.collectionspro.eu/jam/mm/utils";
modeltype kernel uses "http://www.collectionspro.eu/jam/mm/kernel";
modeltype services uses "http://www.collectionspro.eu/jam/mm/services";
modeltype expressions uses "http://www.collectionspro.eu/jam/mm/expressions";
modeltype saclasses uses "http://www.collectionspro.eu/jam/mm/saclasses";
modeltype sm uses "http://www.collectionspro.eu/jam/mm/sm";
modeltype migrations uses "http://www.collectionspro.eu/jam/mm/sm/migrations";
modeltype extensions uses "http://www.collectionspro.eu/jam/mm/extensions";
modeltype dto uses "http://www.collectionspro.eu/jam/mm/extensions/dto";
modeltype serialization uses "http://www.collectionspro.eu/jam/mm/extensions/serialization";


transformation validate_mm_model(__model : mm);

// If false then warnings are not shown in output but unly their number is reported in the final statement.
configuration property showWarnings : Boolean;
configuration property callAllCode : Boolean;

/*
	This file has been generated by plugin 'eu.collectionspro.mutils.qvtovalidation.m2t'
*/
main() {
	__model.validateAll();
	if callAllCode then {
		__model.callAllCode();
		log("Validation> all callable code called")
	} endif
}

// mm



// utils
query utils::Model::callAllCode() {
	self.validate_utils__Model();
	return;
}
query utils::Model::validate() : __Result {
	return constraintGroup(Set{
		self.validate_utils__Model()
	});
}
query utils::Model::validate_utils__Model() : __Result {
	return constraintGroup(Set{
		constraint("not self.rootElements.oclIsKindOf(Model)->includes(true)",null,self,
			not self.rootElements.oclIsKindOf(Model)->includes(true), null),
		constraint("self.allInstances(kernel::Class)->isUnique(name)",null,self,
			self.allInstances(kernel::Class)->isUnique(name), let clss : Set(kernel::Class) = self.allInstances(kernel::Class) in
				clss->select(c | clss->exists(c2 | c <> c2 and c.name = c2.name))),
		__valid()
	});
}


query utils::OCLLibrary::callAllCode() {
	return;
}
helper utils::OCLLibrary::derivedOperation_utils__OCLLibrary__stableMinus(
	a : OrderedSet(Element)
,	b : OrderedSet(Element)
) : OrderedSet(Element)
{
	return a->iterate(ma; res : OrderedSet(Element) = OrderedSet{}|
	   		if b->includes(ma) then
	   			res
	   		else
	   			res->append(ma)
	   		endif);
}




// kernel
query kernel::NamedElement::callAllCode() {
	self.validate_kernel__NamedElement();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	return;
}
query kernel::NamedElement::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement()
	});
}
query kernel::NamedElement::validate_kernel__NamedElement() : __Result {
	return constraintGroup(Set{
		constraint("self.name.find(' ') = 0",null,self,
			self.name.find(' ') = 0, null),
		constraint("not Set{'self','this','new','class','abstract','interface'}
		->includes(self.name)",null,self,
			not Set{'self','this','new','class','abstract','interface'}
		->includes(self.name), null),
		__valid()
	});
}
helper kernel::NamedElement::derivedFeatures_kernel__NamedElement() {
	var qualifiedName_oclValue : EString := self.allNamespaces()->iterate(ns; res: String = self.name |
						ns.name.concat('.').concat(res));
	var qualifiedPath_oclValue : EString := self.allNamespaces()->iterate(ns; res: String = '' |
						ns.name.concat('.').concat(res));
	return;
}
helper kernel::NamedElement::derivedOperation_kernel__NamedElement__allNamespaces(
) : OrderedSet(Namespace)
{
	return if self.namespace->isEmpty() then
						OrderedSet{}
					else
						self.namespace.allNamespaces()->prepend(self.namespace)
					endif;
}
helper kernel::NamedElement::derivedOperation_kernel__NamedElement__isDistinguishableFrom(
	other : NamedElement
) : EBooleanObject
{
	return self.namespace <> other.namespace or self.name <> other.name;
}


query kernel::Namespace::callAllCode() {
	self.validate_kernel__Namespace();
	self.validate_kernel__NamedElement();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedOperation_kernel__Namespace__membersAreDistinguishable();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	return;
}
query kernel::Namespace::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement(),
		self.validate_kernel__Namespace()
	});
}
query kernel::Namespace::validate_kernel__Namespace() : __Result {
	return constraintGroup(Set{
		constraint("self.membersAreDistinguishable()",null,self,
			self.membersAreDistinguishable(), let members : Set(NamedElement) = self.members -
							(self.members->select(oclIsKindOf(RedefinableElement)).
								oclAsType(RedefinableElement).redefinedElement->asSet()) in
					members->select(m | not members->excluding(m)->forAll(om |
						m.isDistinguishableFrom(om)))),
		__valid()
	});
}
helper kernel::Namespace::derivedOperation_kernel__Namespace__membersAreDistinguishable(
) : EBooleanObject
{
	return self.members->forAll(m | self.members->excluding(m)->forAll(om |
						m.isDistinguishableFrom(om)
					));
}


query kernel::PackageableElement::callAllCode() {
	self.validate_kernel__PackageableElement();
	self.validate_kernel__NamedElement();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	return;
}
query kernel::PackageableElement::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement(),
		self.validate_kernel__PackageableElement()
	});
}
query kernel::PackageableElement::validate_kernel__PackageableElement() : __Result {
	return constraintGroup(Set{
		constraintWeak("self.owningPackage->isEmpty() implies self.oclIsKindOf(Package)",null,self,
			self.owningPackage->isEmpty() implies self.oclIsKindOf(Package), null),
		__valid()
	});
}

query kernel::Package::callAllCode() {
	self.validate_kernel__Namespace();
	self.validate_kernel__PackageableElement();
	self.validate_kernel__NamedElement();
	self.validate_kernel__Package();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedOperation_kernel__Namespace__membersAreDistinguishable();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	return;
}
query kernel::Package::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement(),
		self.validate_kernel__Namespace(),
		self.validate_kernel__PackageableElement(),
		self.validate_kernel__Package()
	});
}
query kernel::Package::validate_kernel__Package() : __Result {
	return constraintGroup(Set{
		constraint("self.name <> self.name.firstToUpper()",null,self,
			self.name <> self.name.firstToUpper(), null),
		__valid()
	});
}

query kernel::InheritableElement::callAllCode() {
	self.validate_kernel__Namespace();
	self.validate_kernel__InheritableElement();
	self.validate_kernel__NamedElement();
	self.derivedFeatures_kernel__InheritableElement();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedOperation_kernel__Namespace__membersAreDistinguishable();
	self.derivedOperation_kernel__InheritableElement__allParents();
	self.derivedOperation_kernel__InheritableElement__membersAreDistinguishable();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	return;
}
query kernel::InheritableElement::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement(),
		self.validate_kernel__Namespace(),
		self.validate_kernel__InheritableElement()
	});
}
query kernel::InheritableElement::validate_kernel__InheritableElement() : __Result {
	return constraintGroup(Set{
		constraint("not self.allParents()->includes(self)",null,self,
			not self.allParents()->includes(self), null),
		constraint("self.isAbstract implies not self.isFinal","Element cannot be both abstract and final.",self,
			self.isAbstract implies not self.isFinal, null),
		constraint("self.parents->forAll(p | not p.isFinal)","Element cannot have a final parent.",self,
			self.parents->forAll(p | not p.isFinal), null),
		__valid()
	});
}
helper kernel::InheritableElement::derivedFeatures_kernel__InheritableElement() {
	var inheritedMembers_oclValue : OrderedSet(NamedElement) := self.parents->collect(p | p.members)->asOrderedSet();
	return;
}
helper kernel::InheritableElement::derivedOperation_kernel__InheritableElement__allParents(
) : Set(InheritableElement)
{
	return self.parents->union(self.parents->collect(p | p.allParents())->asSet());
}
helper kernel::InheritableElement::derivedOperation_kernel__InheritableElement__membersAreDistinguishable(
) : EBooleanObject
{
	return let members : Set(NamedElement) = self.members -
							(self.members->select(oclIsKindOf(RedefinableElement)).
								oclAsType(RedefinableElement).redefinedElement->asSet()) in
					members->forAll(m | members->excluding(m)->forAll(om |
						m.isDistinguishableFrom(om)
					));
}


query kernel::RedefinableElement::callAllCode() {
	self.validate_kernel__RedefinableElement();
	self.validate_kernel__NamedElement();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	return;
}
query kernel::RedefinableElement::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement(),
		self.validate_kernel__RedefinableElement()
	});
}
query kernel::RedefinableElement::validate_kernel__RedefinableElement() : __Result {
	return constraintGroup(Set{
		constraint("self.redefinedElement->notEmpty() implies
					self.redefinedElement.isRedefinableBy(self)",null,self,
			self.redefinedElement->notEmpty() implies
					self.redefinedElement.isRedefinableBy(self), null),
		__valid()
	});
}
helper kernel::RedefinableElement::derivedOperation_kernel__RedefinableElement__isRedefinableBy(
	redefinee : RedefinableElement
) : EBooleanObject
{
	return false;
}
helper kernel::RedefinableElement::derivedOperation_kernel__RedefinableElement__redefines(
	other : RedefinableElement
) : EBooleanObject
{
	return if self.redefinedElement->isEmpty() then
						false
					else
						if self.redefinedElement = other then
							true
						else
							self.redefinedElement.redefines(other)
						endif
					endif;
}


query kernel::TemplateableElement::callAllCode() {
	self.validate_kernel__Namespace();
	self.validate_kernel__NamedElement();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedOperation_kernel__Namespace__membersAreDistinguishable();
	self.derivedOperation_kernel__TemplateableElement__getAllTypeParameters();
	self.derivedOperation_kernel__TemplateableElement__hasTypeParameters();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	return;
}
query kernel::TemplateableElement::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement(),
		self.validate_kernel__Namespace(),
		__valid()
	});
}
helper kernel::TemplateableElement::derivedOperation_kernel__TemplateableElement__getAllTypeParameters(
) : OrderedSet(TypeParameter)
{
	return self.typeParameters->asSequence()->union(
				if self.getEnclosingElement()->notEmpty() then
					self.getEnclosingElement().getAllTypeParameters()->asSequence()
				else Sequence{} endif
			)->asOrderedSet();
}
helper kernel::TemplateableElement::derivedOperation_kernel__TemplateableElement__hasTypeParameters(
) : EBoolean
{
	return self.getAllTypeParameters()->notEmpty();
}


query kernel::TypeParameter::callAllCode() {
	self.validate_kernel__NamedElement();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	return;
}
query kernel::TypeParameter::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement(),
		__valid()
	});
}

query kernel::TypeSpecification::callAllCode() {
	self.derivedFeatures_kernel__TypeSpecification();
	return;
}
helper kernel::TypeSpecification::derivedFeatures_kernel__TypeSpecification() {
	var __referencedClasses_oclValue : Set(Class) := self.getReferencedClasses();
	return;
}

query kernel::TypeArgument::callAllCode() {
	self.derivedFeatures_kernel__TypeArgument();
	return;
}
helper kernel::TypeArgument::derivedFeatures_kernel__TypeArgument() {
	var __referencedClasses_oclValue : Set(Class) := self.getReferencedClasses();
	return;
}

query kernel::SpecifiedTypeArgument::callAllCode() {
	self.derivedFeatures_kernel__TypeArgument();
	self.derivedOperation_kernel__SpecifiedTypeArgument__getReferencedClasses();
	self.derivedOperation_kernel__SpecifiedTypeArgument__isWildcard();
	return;
}
helper kernel::SpecifiedTypeArgument::derivedOperation_kernel__SpecifiedTypeArgument__getReferencedClasses(
) : Set(Class)
{
	return self.type.getReferencedClasses();
}
helper kernel::SpecifiedTypeArgument::derivedOperation_kernel__SpecifiedTypeArgument__isWildcard(
) : EBoolean
{
	return false;
}


query kernel::Wildcard::callAllCode() {
	self.derivedFeatures_kernel__TypeArgument();
	self.derivedOperation_kernel__Wildcard__getReferencedClasses();
	self.derivedOperation_kernel__Wildcard__isWildcard();
	return;
}
helper kernel::Wildcard::derivedOperation_kernel__Wildcard__getReferencedClasses(
) : Set(Class)
{
	return let types : Set(TypeSpecification) = Set{self.lowerBound,self.upperBound} in
					if types->isEmpty() then
						Set{}
					else
						types.getReferencedClasses()->asSet()
					endif;
}
helper kernel::Wildcard::derivedOperation_kernel__Wildcard__isWildcard(
) : EBoolean
{
	return true;
}


query kernel::ConcreteTypeSpecification::callAllCode() {
	self.validate_kernel__ConcreteTypeSpecification();
	self.derivedFeatures_kernel__TypeSpecification();
	self.derivedOperation_kernel__ConcreteTypeSpecification__getReferencedClasses();
	self.derivedOperation_kernel__ConcreteTypeSpecification__isConcrete();
	self.derivedOperation_kernel__ConcreteTypeSpecification__getConcreteClass();
	self.derivedOperation_kernel__ConcreteTypeSpecification__getClassInContainer();
	return;
}
query kernel::ConcreteTypeSpecification::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__ConcreteTypeSpecification()
	});
}
query kernel::ConcreteTypeSpecification::validate_kernel__ConcreteTypeSpecification() : __Result {
	return constraintGroup(Set{
		constraint("self._concreteClass.typeParameters->size() = self.typeArguments->size()",null,self,
			self._concreteClass.typeParameters->size() = self.typeArguments->size(), null),
		__valid()
	});
}
helper kernel::ConcreteTypeSpecification::derivedOperation_kernel__ConcreteTypeSpecification__getReferencedClasses(
) : Set(Class)
{
	return Set{self._concreteClass}
						->union(self.typeArguments.getReferencedClasses()->asSet());
}
helper kernel::ConcreteTypeSpecification::derivedOperation_kernel__ConcreteTypeSpecification__getTypeArgument(
	param : TypeParameter
) : TypeArgument
{
	return if self._concreteClass.typeParameters->includes(param) then
						self.typeArguments->at(
							self._concreteClass.typeParameters->indexOf(param)
						) -- TODO ??? ordred
					else
						self._concreteClass.parentTypes.getTypeArgument(param)->asSequence()->first()
					endif;
}
helper kernel::ConcreteTypeSpecification::derivedOperation_kernel__ConcreteTypeSpecification__hasSuperType(
	other : TypeSpecification
) : EBoolean
{
	return if not other.oclIsKindOf(ConcreteTypeSpecification) then
						false
					else
						let cts : ConcreteTypeSpecification = other.oclAsType(ConcreteTypeSpecification) in
						-- Containers
						if self._concreteClass.isContainer then
							-- The container must be of the same type
							self._concreteClass = cts._concreteClass
							and self.typeArguments->size() = 1
							and cts.typeArguments->size() = 1
							and self.typeArguments->first().oclAsType(SpecifiedTypeArgument).type
								.hasSuperType(cts.typeArguments->first().oclAsType(SpecifiedTypeArgument).type)
						-- Not containers
						else
							-- Generics
							if self.typeArguments->notEmpty() then
								false
							-- simple concrete Class
							else
								self._concreteClass.hasSuperClass(cts._concreteClass)
									and self._concreteClass.typeParameters->isEmpty()
							endif
						endif
					endif;
}
helper kernel::ConcreteTypeSpecification::derivedOperation_kernel__ConcreteTypeSpecification__isConcrete(
) : EBoolean
{
	return true;
}
helper kernel::ConcreteTypeSpecification::derivedOperation_kernel__ConcreteTypeSpecification__getConcreteClass(
) : Class
{
	return self._concreteClass;
}
helper kernel::ConcreteTypeSpecification::derivedOperation_kernel__ConcreteTypeSpecification__getClassInContainer(
) : Class
{
	return if self._concreteClass.isContainer then
						self.typeArguments->first().oclAsType(kernel::SpecifiedTypeArgument).type
							.oclAsType(kernel::ConcreteTypeSpecification)._concreteClass
					else null endif;
}


query kernel::TypeParameterReference::callAllCode() {
	self.derivedFeatures_kernel__TypeSpecification();
	self.derivedOperation_kernel__TypeParameterReference__getReferencedClasses();
	self.derivedOperation_kernel__TypeParameterReference__isConcrete();
	self.derivedOperation_kernel__TypeParameterReference__getConcreteClass();
	return;
}
helper kernel::TypeParameterReference::derivedOperation_kernel__TypeParameterReference__getReferencedClasses(
) : Set(Class)
{
	return Set{};
}
helper kernel::TypeParameterReference::derivedOperation_kernel__TypeParameterReference__hasSuperType(
	other : TypeSpecification
) : EBoolean
{
	return if self.referencedTypeParameter.upperBound->notEmpty() then
						self.referencedTypeParameter.upperBound.hasSuperType(other)
					else
						false
					endif;
}
helper kernel::TypeParameterReference::derivedOperation_kernel__TypeParameterReference__isConcrete(
) : EBoolean
{
	return false;
}
helper kernel::TypeParameterReference::derivedOperation_kernel__TypeParameterReference__getConcreteClass(
) : Class
{
	return null;
}


query kernel::ClassImplementation::callAllCode() {
	self.validate_kernel__ClassImplementation();
	return;
}
query kernel::ClassImplementation::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__ClassImplementation()
	});
}
query kernel::ClassImplementation::validate_kernel__ClassImplementation() : __Result {
	return constraintGroup(Set{
		constraint("self.isPrimitive implies self.typeArguments->isEmpty()",null,self,
			self.isPrimitive implies self.typeArguments->isEmpty(), null),
		constraint("self.isPrimitive implies self.implementationInterface->isEmpty()",null,self,
			self.isPrimitive implies self.implementationInterface->isEmpty(), null),
		__valid()
	});
}

query kernel::Class::callAllCode() {
	self.validate_kernel__Namespace();
	self.validate_kernel__InheritableElement();
	self.validate_kernel__PackageableElement();
	self.validate_kernel__NamedElement();
	self.validate_kernel__Class();
	self.derivedFeatures_kernel__InheritableElement();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedFeatures_kernel__Class();
	self.derivedOperation_kernel__Namespace__membersAreDistinguishable();
	self.derivedOperation_kernel__InheritableElement__allParents();
	self.derivedOperation_kernel__InheritableElement__membersAreDistinguishable();
	self.derivedOperation_kernel__TemplateableElement__getAllTypeParameters();
	self.derivedOperation_kernel__TemplateableElement__hasTypeParameters();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	self.derivedOperation_kernel__Class__isNative();
	self.derivedOperation_kernel__Class__isNativeNotPrimitive();
	self.derivedOperation_kernel__Class__isPrimitive();
	self.derivedOperation_kernel__Class__isObjectType();
	self.derivedOperation_kernel__Class__getEnclosingElement();
	self.derivedOperation_kernel__Class__getVisibleProperties();
	self.derivedOperation_kernel__Class__getAllVisibleProperties();
	self.derivedOperation_kernel__Class__allParentClasses();
	self.derivedOperation_kernel__Class__allParentOperations();
	self.derivedOperation_kernel__Class__allParentProperties();
	self.derivedOperation_kernel__Class__allParentParameters();
	self.derivedOperation_kernel__Class__allOperations();
	self.derivedOperation_kernel__Class__getAllSAOperations();
	self.derivedOperation_kernel__Class__getOwnedSAOperations();
	self.derivedOperation_kernel__Class__allProperties();
	self.derivedOperation_kernel__Class__allParameters();
	self.derivedOperation_kernel__Class__allOperators();
	self.derivedOperation_kernel__Class__allPrimitiveOperators();
	self.derivedOperation_kernel__Class__getReferencedClasses();
	return;
}
query kernel::Class::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement(),
		self.validate_kernel__Namespace(),
		self.validate_kernel__InheritableElement(),
		self.validate_kernel__PackageableElement(),
		self.validate_kernel__Class()
	});
}
query kernel::Class::validate_kernel__Class() : __Result {
	return constraintGroup(Set{
		constraint("self.isPrimitive() implies (
					self.allProperties()->isEmpty() and
					self.allParameters()->isEmpty() and
					self.typeParameters->isEmpty()
			)",null,self,
			self.isPrimitive() implies (
					self.allProperties()->isEmpty() and
					self.allParameters()->isEmpty() and
					self.typeParameters->isEmpty()
			), null),
		constraint("self.isPrimitive() implies self.parentClasses->forAll(isPrimitive())",null,self,
			self.isPrimitive() implies self.parentClasses->forAll(isPrimitive()), null),
		constraint("self.isNativeNotPrimitive() implies self.parentClasses->isEmpty()",null,self,
			self.isNativeNotPrimitive() implies self.parentClasses->isEmpty(), null),
		constraint("not self.isPrimitive() implies self.parentClasses->forAll(x | not x.isPrimitive())",null,self,
			not self.isPrimitive() implies self.parentClasses->forAll(x | not x.isPrimitive()), null),
		constraint("self.ownedProperties->includesAll(self.ownedParameters)",null,self,
			self.ownedProperties->includesAll(self.ownedParameters), null),
		constraint("self.allProperties()->includesAll(self.allParameters())",null,self,
			self.allProperties()->includesAll(self.allParameters()), null),
		constraint("self.allProperties().getGetterName()->union(self.allProperties().getSetterName())
				->intersection(self.allOperations().name)->isEmpty()",null,self,
			self.allProperties().getGetterName()->union(self.allProperties().getSetterName())
				->intersection(self.allOperations().name)->isEmpty(), null),
		constraint("self.allParentClasses()->exists(oclIsKindOf(SAClass)) implies self.oclIsKindOf(SAClass)",null,self,
			self.allParentClasses()->exists(oclIsKindOf(SAClass)) implies self.oclIsKindOf(SAClass), null),
		constraint("self.parentTypes->isUnique(_concreteClass)",null,self,
			self.parentTypes->isUnique(_concreteClass), null),
		constraint("not self.allParentClasses().name->includes(self.name)",null,self,
			not self.allParentClasses().name->includes(self.name), null),
		constraint("self.parentTypes->size() <= 1",null,self,
			self.parentTypes->size() <= 1, null),
		constraint("self.parentTypes->forAll(pt | pt.getConcreteClass().typeParameters->size() = pt.typeArguments->size()
											and pt.typeArguments->forAll(not isWildcard()))",null,self,
			self.parentTypes->forAll(pt | pt.getConcreteClass().typeParameters->size() = pt.typeArguments->size()
											and pt.typeArguments->forAll(not isWildcard())), null),
		constraint("self.allOperations()->exists(o | o.isAbstract) implies self.isAbstract",null,self,
			self.allOperations()->exists(o | o.isAbstract) implies self.isAbstract, null),
		constraint("(self.allOperations()->select(o | o.isAbstract).name->asSet()-self.allOperations()->select(o | not o.isAbstract).name->asSet())
			 	->notEmpty() implies self.isAbstract",null,self,
			(self.allOperations()->select(o | o.isAbstract).name->asSet()-self.allOperations()->select(o | not o.isAbstract).name->asSet())
			 	->notEmpty() implies self.isAbstract, (self.allOperations()->select(o | o.isAbstract).name->asSet()-self.allOperations()->select(o | not o.isAbstract).name->asSet())),
		constraint("self.isContainer implies
		(self.typeParameters->size() = 1 and self.isNativeNotPrimitive() and self.allProperties()->size() = 0)",null,self,
			self.isContainer implies
		(self.typeParameters->size() = 1 and self.isNativeNotPrimitive() and self.allProperties()->size() = 0), null),
		constraint("self.allPrimitiveOperators()->isUnique(token)",null,self,
			self.allPrimitiveOperators()->isUnique(token), null),
		constraint("self.allOperators()->select(isUnary)->isUnique(token)",null,self,
			self.allOperators()->select(isUnary)->isUnique(token), null),
		constraint("let transferable : Boolean = self.libDTO().isPackageableElemTransferable(self) in
			    self.allParentClasses()->forAll(cl |
			    	transferable = self.libDTO().isPackageableElemTransferable(cl))
				","Transferable class has all parents transferable and not transferable has all parents not transferable",self,
			let transferable : Boolean = self.libDTO().isPackageableElemTransferable(self) in
			    self.allParentClasses()->forAll(cl |
			    	transferable = self.libDTO().isPackageableElemTransferable(cl))
				, null),
		__valid()
	});
}
helper kernel::Class::derivedFeatures_kernel__Class() {
	var __referencedClasses_oclValue : Set(Class) := self.getReferencedClasses();
	var parentClasses_oclValue : Set(Class) := self.parentTypes.getConcreteClass()->asSet();
	return;
}
helper kernel::Class::derivedOperation_kernel__Class__getBinding(
	param : TypeParameter
) : TypeArgument
{
	return let arg : TypeArgument = self.parentTypes.getTypeArgument(param)->asSequence()->first() in
					if arg->notEmpty() then
						if arg.oclIsKindOf(TypeParameterReference) then
							self.getBinding(arg.oclAsType(TypeParameterReference).referencedTypeParameter)
						else
							arg
						endif
					else null endif
				;
}
helper kernel::Class::derivedOperation_kernel__Class__isNative(
) : EBoolean
{
	return self.implementation->notEmpty();
}
helper kernel::Class::derivedOperation_kernel__Class__isNativeNotPrimitive(
) : EBoolean
{
	return self.implementation->notEmpty() and not self.implementation.isPrimitive;
}
helper kernel::Class::derivedOperation_kernel__Class__isPrimitive(
) : EBoolean
{
	return self.implementation->notEmpty() and self.implementation.isPrimitive;
}
helper kernel::Class::derivedOperation_kernel__Class__isObjectType(
) : EBoolean
{
	return not self.isPrimitive() or self.libString().contains(self.implementation.implementationClass,'.');
}
helper kernel::Class::derivedOperation_kernel__Class__hasSuperClass(
	other : Class
) : EBoolean
{
	return self = other or self.allParentClasses()->includes(other);
}
helper kernel::Class::derivedOperation_kernel__Class__getEnclosingElement(
) : TemplateableElement
{
	return null;
}
helper kernel::Class::derivedOperation_kernel__Class__getVisibleProperties(
) : Set(Property)
{
	return self.ownedProperties->select(isReadable or isSettable);
}
helper kernel::Class::derivedOperation_kernel__Class__getAllVisibleProperties(
) : Set(Property)
{
	return self.getVisibleProperties()->union(
						self.allParentClasses().getVisibleProperties()->asSet()
					);
}
helper kernel::Class::derivedOperation_kernel__Class__allParentClasses(
) : Set(Class)
{
	return self.allParents().oclAsType(Class)->asSet();
}
helper kernel::Class::derivedOperation_kernel__Class__allParentOperations(
) : Set(Operation)
{
	return self.parentClasses.allOperations()->asSet();
}
helper kernel::Class::derivedOperation_kernel__Class__allParentProperties(
) : Set(Property)
{
	return self.parentClasses.allProperties()->asSet();
}
helper kernel::Class::derivedOperation_kernel__Class__allParentParameters(
) : Set(Property)
{
	return self.parentClasses.allParameters()->asSet();
}
helper kernel::Class::derivedOperation_kernel__Class__allOperations(
) : Set(Operation)
{
	return self.ownedOperations->union(
						self.parentClasses.allOperations()->asSet()
				- self.ownedOperations.redefinedElement.oclAsType(Operation)->asSet()
			);
}
helper kernel::Class::derivedOperation_kernel__Class__getAllSAOperations(
) : Set(Operation)
{
	return if self.oclIsKindOf(saclasses::SAOperationsOwner) then
						self.oclAsType(saclasses::SAOperationsOwner).allStateAwareOperations()
					else
						Set{}.oclAsType(kernel::Operation)->asSet()
					endif;
}
helper kernel::Class::derivedOperation_kernel__Class__getOwnedSAOperations(
) : Set(Operation)
{
	return if self.oclIsKindOf(saclasses::SAOperationsOwner) then
						self.oclAsType(saclasses::SAOperationsOwner).ownedStateAwareOperations
					else
						Set{}.oclAsType(kernel::Operation)->asSet()
					endif;
}
helper kernel::Class::derivedOperation_kernel__Class__allProperties(
) : Set(Property)
{
	return self.ownedProperties->union(
						self.allParentClasses().ownedProperties->asSet()
					);
}
helper kernel::Class::derivedOperation_kernel__Class__allParameters(
) : Set(Property)
{
	return self.ownedParameters->union(
						self.allParentClasses().ownedParameters->asSet()
					);
}
helper kernel::Class::derivedOperation_kernel__Class__allOperators(
) : Set(Operator)
{
	return self.ownedOperators->union(
						self.allParentClasses().ownedOperators->asSet()
					);
}
helper kernel::Class::derivedOperation_kernel__Class__allPrimitiveOperators(
) : Set(PrimitiveOperator)
{
	return self.ownedPrimitiveOperators->union(
						self.allParentClasses().ownedPrimitiveOperators->asSet()
					);
}
helper kernel::Class::derivedOperation_kernel__Class__findUnaryOperator(
	opToken : EString
) : Operator
{
	return self.allOperators()->select(
						op | op.isUnary and op.token = opToken
					)->asSequence()->first();
}
helper kernel::Class::derivedOperation_kernel__Class__findBinaryOperators(
	opToken : EString
,	parameterClass : Class
) : Set(Operator)
{
	return self.allOperators()->select(
						op | not op.isUnary and op.token = opToken and op.operation.parameters->notEmpty()
							and parameterClass.hasSuperClass(op.operation.parameters->first().getConcreteClass())
					);
}
helper kernel::Class::derivedOperation_kernel__Class__findExactBinaryOperator(
	opToken : EString
,	parameterClass : Class
) : Operator
{
	return self.allOperators()->select(
						op | not op.isUnary and op.token = opToken and op.operation.parameters->notEmpty()
							and parameterClass = op.operation.parameters->first().getConcreteClass()
					)->asSequence()->first();
}
helper kernel::Class::derivedOperation_kernel__Class__getReferencedClasses(
) : Set(Class)
{
	return self.ownedOperations.getReferencedClasses()->union(
						self.ownedProperties.type.getReferencedClasses()->asSet()
				   )->union(
						self.parentClasses->asSet()
				   )->union(
				   		self.typeParameters.upperBound->reject(x|x->isEmpty()).getReferencedClasses()->asSet()
				   )->asSet();
}


query kernel::EnumerationLiteral::callAllCode() {
	self.validate_kernel__NamedElement();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	return;
}
query kernel::EnumerationLiteral::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement(),
		__valid()
	});
}

query kernel::Enumeration::callAllCode() {
	self.validate_kernel__Namespace();
	self.validate_kernel__InheritableElement();
	self.validate_kernel__PackageableElement();
	self.validate_kernel__NamedElement();
	self.validate_kernel__Class();
	self.validate_kernel__Enumeration();
	self.derivedFeatures_kernel__InheritableElement();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedFeatures_kernel__Class();
	self.derivedOperation_kernel__Namespace__membersAreDistinguishable();
	self.derivedOperation_kernel__InheritableElement__allParents();
	self.derivedOperation_kernel__InheritableElement__membersAreDistinguishable();
	self.derivedOperation_kernel__TemplateableElement__getAllTypeParameters();
	self.derivedOperation_kernel__TemplateableElement__hasTypeParameters();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	self.derivedOperation_kernel__Class__isNative();
	self.derivedOperation_kernel__Class__isNativeNotPrimitive();
	self.derivedOperation_kernel__Class__isPrimitive();
	self.derivedOperation_kernel__Class__isObjectType();
	self.derivedOperation_kernel__Class__getEnclosingElement();
	self.derivedOperation_kernel__Class__getVisibleProperties();
	self.derivedOperation_kernel__Class__getAllVisibleProperties();
	self.derivedOperation_kernel__Class__allParentClasses();
	self.derivedOperation_kernel__Class__allParentOperations();
	self.derivedOperation_kernel__Class__allParentProperties();
	self.derivedOperation_kernel__Class__allParentParameters();
	self.derivedOperation_kernel__Class__allOperations();
	self.derivedOperation_kernel__Class__getAllSAOperations();
	self.derivedOperation_kernel__Class__getOwnedSAOperations();
	self.derivedOperation_kernel__Class__allProperties();
	self.derivedOperation_kernel__Class__allParameters();
	self.derivedOperation_kernel__Class__allOperators();
	self.derivedOperation_kernel__Class__allPrimitiveOperators();
	self.derivedOperation_kernel__Class__getReferencedClasses();
	return;
}
query kernel::Enumeration::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement(),
		self.validate_kernel__Namespace(),
		self.validate_kernel__InheritableElement(),
		self.validate_kernel__PackageableElement(),
		self.validate_kernel__Class(),
		self.validate_kernel__Enumeration()
	});
}
query kernel::Enumeration::validate_kernel__Enumeration() : __Result {
	return constraintGroup(Set{
		constraint("self.parentClasses->select(oclIsKindOf(kernel::Enumeration))->isEmpty()","Enumeration cannot inherit from other Enumeration",self,
			self.parentClasses->select(oclIsKindOf(kernel::Enumeration))->isEmpty(), null),
		constraint("self.allParameters()->isEmpty() and self.allProperties()->isEmpty()
				 and self.typeParameters->isEmpty()",null,self,
			self.allParameters()->isEmpty() and self.allProperties()->isEmpty()
				 and self.typeParameters->isEmpty(), null),
		__valid()
	});
}

query kernel::TypedElement::callAllCode() {
	self.derivedOperation_kernel__TypedElement__getConcreteClass();
	return;
}
helper kernel::TypedElement::derivedOperation_kernel__TypedElement__getConcreteClass(
) : Class
{
	return if self.type->notEmpty() then
						self.type.getConcreteClass()
					else null endif;
}


query kernel::Operation::callAllCode() {
	self.validate_kernel__RedefinableElement();
	self.validate_kernel__Namespace();
	self.validate_kernel__Operation();
	self.validate_kernel__NamedElement();
	self.derivedFeatures_kernel__Operation();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedOperation_kernel__TypedElement__getConcreteClass();
	self.derivedOperation_kernel__Namespace__membersAreDistinguishable();
	self.derivedOperation_kernel__Operation__hasImplementation();
	self.derivedOperation_kernel__Operation__hasBody();
	self.derivedOperation_kernel__Operation__getBody();
	self.derivedOperation_kernel__Operation__implementedAsOperator();
	self.derivedOperation_kernel__Operation__getEnclosingElement();
	self.derivedOperation_kernel__Operation__getReferencedClasses();
	self.derivedOperation_kernel__TemplateableElement__getAllTypeParameters();
	self.derivedOperation_kernel__TemplateableElement__hasTypeParameters();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	return;
}
query kernel::Operation::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement(),
		self.validate_kernel__RedefinableElement(),
		self.validate_kernel__Namespace(),
		self.validate_kernel__Operation()
	});
}
query kernel::Operation::validate_kernel__Operation() : __Result {
	return constraintGroup(Set{
		constraint("self.isQuery implies self.type->notEmpty()","Query must return a value.",self,
			self.isQuery implies self.type->notEmpty(), null),
		constraint("self.isNative implies self.owningClass.isNative()",null,self,
			self.isNative implies self.owningClass.isNative(), null),
		constraint("self.redefinedOperation->notEmpty() implies
					(self.isQuery = self.redefinedOperation.isQuery
					and self.isStatic = self.redefinedOperation.isStatic
					and not self.redefinedOperation.isFinal
					and not self.isAbstract)",null,self,
			self.redefinedOperation->notEmpty() implies
					(self.isQuery = self.redefinedOperation.isQuery
					and self.isStatic = self.redefinedOperation.isStatic
					and not self.redefinedOperation.isFinal
					and not self.isAbstract), Set{self.redefinedOperation}),
		constraint("self.parameters->isUnique(name)",null,self,
			self.parameters->isUnique(name), null),
		constraintWeak("self.redefinedOperation->notEmpty() implies
				(self.parameters.name->includesAll(self.redefinedOperation.parameters.name) and
				 self.redefinedOperation.parameters.name->includesAll(self.parameters.name))",null,self,
			self.redefinedOperation->notEmpty() implies
				(self.parameters.name->includesAll(self.redefinedOperation.parameters.name) and
				 self.redefinedOperation.parameters.name->includesAll(self.parameters.name)), Set{self.redefinedOperation}),
		constraint("not self.isStatic","static operations not supported yet",self,
			not self.isStatic, null),
		constraint("self.isQuery and self.hasBody() implies
				self.getBody().expressions->size() >= 1",null,self,
			self.isQuery and self.hasBody() implies
				self.getBody().expressions->size() >= 1, null),
		constraint("self.hasImplementation() implies not self.isAbstract",null,self,
			self.hasImplementation() implies not self.isAbstract, null),
		constraint("self.implementation->notEmpty() implies
					(self.owningClass.isPrimitive() or not self.implementation.oclIsKindOf(OperationAsOperator))","Operation can be implemented as primitive operator only if the owning class is primitive",self,
			self.implementation->notEmpty() implies
					(self.owningClass.isPrimitive() or not self.implementation.oclIsKindOf(OperationAsOperator)), null),
		__valid()
	});
}
helper kernel::Operation::derivedFeatures_kernel__Operation() {
	var __referencedClasses_oclValue : Set(Class) := self.getReferencedClasses();
	return;
}
helper kernel::Operation::derivedOperation_kernel__Operation__hasImplementation(
) : EBoolean
{
	return self.implementation->notEmpty();
}
helper kernel::Operation::derivedOperation_kernel__Operation__hasBody(
) : EBoolean
{
	return self.implementation->notEmpty() and self.implementation.oclIsKindOf(OperationBody);
}
helper kernel::Operation::derivedOperation_kernel__Operation__getBody(
) : OperationBody
{
	return if self.hasBody() then
						self.implementation.oclAsType(OperationBody)
					else null endif;
}
helper kernel::Operation::derivedOperation_kernel__Operation__implementedAsOperator(
) : EBoolean
{
	return self.implementation->notEmpty() and self.implementation.oclIsKindOf(OperationAsOperator);
}
helper kernel::Operation::derivedOperation_kernel__Operation__getEnclosingElement(
) : TemplateableElement
{
	return self.owningClass;
}
helper kernel::Operation::derivedOperation_kernel__Operation__isRedefinableBy(
	redefinee : RedefinableElement
) : EBooleanObject
{
	return redefinee.oclIsKindOf(Operation) and
					let op: Operation = redefinee.oclAsType(Operation) in
						op.owningClass.allParentClasses()->includes(self.owningClass) and
						self.parameters->size() = op.parameters->size() and
						self.parameters->forAll(par |
							par.type.getConcreteClass()->notEmpty() and
							par.type.getConcreteClass() = op.parameters->at(self.parameters->indexOf(par)).type.getConcreteClass()
--							true
						) and
						((self.type->isEmpty() and op.type->isEmpty()) or
						 (self.type->notEmpty() and op.type->notEmpty() and
							 op.type.hasSuperType(self.type)
							)
						);
}
helper kernel::Operation::derivedOperation_kernel__Operation__getReferencedClasses(
) : Set(Class)
{
	return let types : Set(TypeSpecification) = self.parameters->collect(type)->asSet()->union(Set{self.type}) in
					if types->isEmpty() then
						Set{}
					else
						types.getReferencedClasses()->asSet()
					endif;
}



query kernel::OperationBody::callAllCode() {
	self.derivedOperation_kernel__OperationBody__isEmpty();
	return;
}
helper kernel::OperationBody::derivedOperation_kernel__OperationBody__isEmpty(
) : EBoolean
{
	return self.expressions->isEmpty();
}


query kernel::OperationAsOperator::callAllCode() {
	self.validate_kernel__OperationAsOperator();
	return;
}
query kernel::OperationAsOperator::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__OperationAsOperator()
	});
}
query kernel::OperationAsOperator::validate_kernel__OperationAsOperator() : __Result {
	return constraintGroup(Set{
		constraint("self.owningOperation->notEmpty() and
				self.owningOperation.owningClass = self.primitiveOperator.owningClass",null,self,
			self.owningOperation->notEmpty() and
				self.owningOperation.owningClass = self.primitiveOperator.owningClass, null),
		__valid()
	});
}

query kernel::ExternalOperationBody::callAllCode() {
	self.validate_kernel__ExternalOperationBody();
	self.derivedOperation_kernel__OperationBody__isEmpty();
	return;
}
query kernel::ExternalOperationBody::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__ExternalOperationBody()
	});
}
query kernel::ExternalOperationBody::validate_kernel__ExternalOperationBody() : __Result {
	return constraintGroup(Set{
		constraint("not self.operation.isAbstract",null,self,
			not self.operation.isAbstract, null),
		__valid()
	});
}

query kernel::ClassOperationBodiesExtent::callAllCode() {
	self.validate_kernel__ClassOperationBodiesExtent();
	return;
}
query kernel::ClassOperationBodiesExtent::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__ClassOperationBodiesExtent()
	});
}
query kernel::ClassOperationBodiesExtent::validate_kernel__ClassOperationBodiesExtent() : __Result {
	return constraintGroup(Set{
		constraint("self.extendingClass.ownedOperations->includesAll(self.bodies.operation)",null,self,
			self.extendingClass.ownedOperations->includesAll(self.bodies.operation), null),
		__valid()
	});
}


query kernel::Property::callAllCode() {
	self.validate_kernel__NamedElement();
	self.validate_kernel__Property();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedOperation_kernel__TypedElement__getConcreteClass();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	self.derivedOperation_kernel__Property__getGetterName();
	self.derivedOperation_kernel__Property__getSetterName();
	self.derivedOperation_kernel__Property__getTranslatedPropertyName();
	self.derivedOperation_kernel__Property__isContainer();
	self.derivedOperation_kernel__Property__getClassInContainer();
	return;
}
query kernel::Property::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement(),
		self.validate_kernel__Property()
	});
}
query kernel::Property::validate_kernel__Property() : __Result {
	return constraintGroup(Set{
		constraint("not self.isReadable implies not self.isSettable",null,self,
			not self.isReadable implies not self.isSettable, null),
		constraintWeak("self.initialValue->notEmpty() implies not self.owningClass.allParameters()->includes(self)","Initialization expression is overriden by setting as a class parameter",self,
			self.initialValue->notEmpty() implies not self.owningClass.allParameters()->includes(self), null),
		constraint("self.type->notEmpty()",null,self,
			self.type->notEmpty(), null),
		constraint("self.type.isConcrete() and
					self.type.getConcreteClass().isContainer implies
				self.initialValue->isEmpty()","Collection is initialized to empty collection, should not be initialized by expression (for now)",self,
			self.type.isConcrete() and
					self.type.getConcreteClass().isContainer implies
				self.initialValue->isEmpty(), null),
		constraint("self.opposite->notEmpty() implies
					self.opposite.opposite->notEmpty() and
					self.opposite.opposite = self and
					self.opposite <> self
				",null,self,
			self.opposite->notEmpty() implies
					self.opposite.opposite->notEmpty() and
					self.opposite.opposite = self and
					self.opposite <> self
				, null),
		__valid()
	});
}
helper kernel::Property::derivedOperation_kernel__Property__getGetterName(
) : EString
{
	return self.libString().constructGetterName(self.name);
}
helper kernel::Property::derivedOperation_kernel__Property__getSetterName(
) : EString
{
	return self.libString().constructSetterName(self.name);
}
helper kernel::Property::derivedOperation_kernel__Property__getTranslatedPropertyName(
) : EString
{
	return self.libString().constructPropertyName(self.name);
}
helper kernel::Property::derivedOperation_kernel__Property__isContainer(
) : EBooleanObject
{
	return self.type.isConcrete() and self.getConcreteClass().isContainer;
}
helper kernel::Property::derivedOperation_kernel__Property__getClassInContainer(
) : Class
{
	return if self.isContainer() then
						self.type.oclAsType(kernel::ConcreteTypeSpecification).getClassInContainer()
					else null endif;
}


query kernel::Parameter::callAllCode() {
	self.validate_kernel__Parameter();
	self.validate_kernel__NamedElement();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedOperation_kernel__TypedElement__getConcreteClass();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	return;
}
query kernel::Parameter::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement(),
		self.validate_kernel__Parameter()
	});
}
query kernel::Parameter::validate_kernel__Parameter() : __Result {
	return constraintGroup(Set{
		constraint("self.type->notEmpty()",null,self,
			self.type->notEmpty(), null),
		__valid()
	});
}

query kernel::Operator::callAllCode() {
	self.validate_kernel__Operator();
	return;
}
query kernel::Operator::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__Operator()
	});
}
query kernel::Operator::validate_kernel__Operator() : __Result {
	return constraintGroup(Set{
		constraint("self.operation.owningClass.parents->union(Set{self.operation.owningClass})->includes(self.owningClass)","Operators must be implemented by operations form the same class or parent class",self,
			self.operation.owningClass.parents->union(Set{self.operation.owningClass})->includes(self.owningClass), null),
		constraint("self.isUnary implies self.operation.parameters->size() = 0","Unary operator's operation must not have any parameter",self,
			self.isUnary implies self.operation.parameters->size() = 0, null),
		constraint("not self.isUnary implies self.operation.parameters->size() = 1","Binary operator's operation must have exactly one parameter",self,
			not self.isUnary implies self.operation.parameters->size() = 1, null),
		constraint("Set{'<','<=','==','!=','>=','>','not','and','or','xor','>>','<<','^','&',
					'|','+','-','*','/','/'+'/','%%'}->includes(self.token)",null,self,
			Set{'<','<=','==','!=','>=','>','not','and','or','xor','>>','<<','^','&',
					'|','+','-','*','/','/'+'/','%%'}->includes(self.token), null),
		__valid()
	});
}



// services
query services::Service::callAllCode() {
	self.validate_kernel__Namespace();
	self.validate_kernel__InheritableElement();
	self.validate_kernel__PackageableElement();
	self.validate_services__Service();
	self.validate_kernel__NamedElement();
	self.validate_kernel__Class();
	self.derivedFeatures_kernel__InheritableElement();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedFeatures_kernel__Class();
	self.derivedOperation_kernel__Namespace__membersAreDistinguishable();
	self.derivedOperation_kernel__InheritableElement__allParents();
	self.derivedOperation_kernel__InheritableElement__membersAreDistinguishable();
	self.derivedOperation_kernel__TemplateableElement__getAllTypeParameters();
	self.derivedOperation_kernel__TemplateableElement__hasTypeParameters();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	self.derivedOperation_kernel__Class__isNative();
	self.derivedOperation_kernel__Class__isNativeNotPrimitive();
	self.derivedOperation_kernel__Class__isPrimitive();
	self.derivedOperation_kernel__Class__isObjectType();
	self.derivedOperation_kernel__Class__getEnclosingElement();
	self.derivedOperation_kernel__Class__getVisibleProperties();
	self.derivedOperation_kernel__Class__getAllVisibleProperties();
	self.derivedOperation_kernel__Class__allParentClasses();
	self.derivedOperation_kernel__Class__allParentOperations();
	self.derivedOperation_kernel__Class__allParentProperties();
	self.derivedOperation_kernel__Class__allParentParameters();
	self.derivedOperation_kernel__Class__allOperations();
	self.derivedOperation_kernel__Class__getAllSAOperations();
	self.derivedOperation_kernel__Class__getOwnedSAOperations();
	self.derivedOperation_kernel__Class__allProperties();
	self.derivedOperation_kernel__Class__allParameters();
	self.derivedOperation_kernel__Class__allOperators();
	self.derivedOperation_kernel__Class__allPrimitiveOperators();
	self.derivedOperation_kernel__Class__getReferencedClasses();
	return;
}
query services::Service::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement(),
		self.validate_kernel__Namespace(),
		self.validate_kernel__InheritableElement(),
		self.validate_kernel__PackageableElement(),
		self.validate_kernel__Class(),
		self.validate_services__Service()
	});
}
query services::Service::validate_services__Service() : __Result {
	return constraintGroup(Set{
		constraint("self.allOperations()->forAll(isStatic=true)","All service's operations has to be static",self,
			self.allOperations()->forAll(isStatic=true), null),
		__valid()
	});
}


// expressions
query expressions::TypedElement::callAllCode() {
	self.derivedFeatures_expressions__TypedElement();
	self.derivedOperation_expressions__TypedElement__getTypeClass();
	return;
}
helper expressions::TypedElement::derivedFeatures_expressions__TypedElement() {
	var drvTypeClass_oclValue : Class := self.getTypeClass();
	return;
}
helper expressions::TypedElement::derivedOperation_expressions__TypedElement__getTypeClass(
) : Class
{
	return null;
}


query expressions::Expression::callAllCode() {
	self.derivedFeatures_expressions__TypedElement();
	self.derivedOperation_expressions__TypedElement__getTypeClass();
	return;
}

query expressions::OpaqueExpression::callAllCode() {
	self.validate_expressions__OpaqueExpression();
	self.derivedFeatures_expressions__TypedElement();
	self.derivedOperation_expressions__TypedElement__getTypeClass();
	return;
}
query expressions::OpaqueExpression::validate() : __Result {
	return constraintGroup(Set{
		self.validate_expressions__OpaqueExpression()
	});
}
query expressions::OpaqueExpression::validate_expressions__OpaqueExpression() : __Result {
	return constraintGroup(Set{
		constraint("self.expression.trim().length() > 0",null,self,
			self.expression.trim().length() > 0, null),
		__valid()
	});
}

query expressions::IntitialObject::callAllCode() {
	self.derivedFeatures_expressions__TypedElement();
	self.derivedOperation_expressions__IntitialObject__getTypeClass();
	self.derivedOperation_expressions__TypedElement__getTypeClass();
	return;
}
helper expressions::IntitialObject::derivedOperation_expressions__IntitialObject__getTypeClass(
) : Class
{
	return self.objectClass;
}



query expressions::Literal::callAllCode() {
	self.derivedFeatures_expressions__TypedElement();
	self.derivedOperation_expressions__TypedElement__getTypeClass();
	return;
}

query expressions::StringLiteral::callAllCode() {
	self.derivedFeatures_expressions__TypedElement();
	self.derivedOperation_expressions__TypedElement__getTypeClass();
	return;
}

query expressions::IntegerLiteral::callAllCode() {
	self.derivedFeatures_expressions__TypedElement();
	self.derivedOperation_expressions__TypedElement__getTypeClass();
	return;
}

query expressions::LongLiteral::callAllCode() {
	self.derivedFeatures_expressions__TypedElement();
	self.derivedOperation_expressions__TypedElement__getTypeClass();
	return;
}

query expressions::FloatingPointLiteral::callAllCode() {
	self.derivedFeatures_expressions__TypedElement();
	self.derivedOperation_expressions__TypedElement__getTypeClass();
	return;
}

query expressions::BooleanLiteral::callAllCode() {
	self.derivedFeatures_expressions__TypedElement();
	self.derivedOperation_expressions__TypedElement__getTypeClass();
	return;
}

query expressions::NullLiteral::callAllCode() {
	self.derivedFeatures_expressions__TypedElement();
	self.derivedOperation_expressions__TypedElement__getTypeClass();
	return;
}

query expressions::Name::callAllCode() {
	self.derivedFeatures_expressions__TypedElement();
	self.derivedOperation_expressions__TypedElement__getTypeClass();
	return;
}

query expressions::SimpleName::callAllCode() {
	self.derivedFeatures_expressions__TypedElement();
	self.derivedOperation_expressions__TypedElement__getTypeClass();
	return;
}

query expressions::QualifiedName::callAllCode() {
	self.derivedFeatures_expressions__TypedElement();
	self.derivedOperation_expressions__TypedElement__getTypeClass();
	return;
}

query expressions::FunctionCall::callAllCode() {
	self.derivedFeatures_expressions__TypedElement();
	self.derivedOperation_expressions__TypedElement__getTypeClass();
	return;
}


query expressions::ArgumentList::callAllCode() {
	return;
}
helper expressions::ArgumentList::derivedOperation_expressions__ArgumentList__matchesOperation(
	operation : Operation
) : EBoolean
{
	return self.arguments->size() = operation.parameters->size() and
					self.arguments->forAll(
						arg | arg.getTypeClass().hasSuperClass(
								operation.parameters->at(self.arguments->indexOf(arg)).getConcreteClass())
					);
}


query expressions::PropertyAccessChain::callAllCode() {
	self.derivedFeatures_expressions__TypedElement();
	self.derivedOperation_expressions__TypedElement__getTypeClass();
	return;
}

query expressions::Operation::callAllCode() {
	self.derivedFeatures_expressions__TypedElement();
	self.derivedOperation_expressions__TypedElement__getTypeClass();
	return;
}

query expressions::Action::callAllCode() {
	self.validate_expressions__Action();
	return;
}
query expressions::Action::validate() : __Result {
	return constraintGroup(Set{
		self.validate_expressions__Action()
	});
}
query expressions::Action::validate_expressions__Action() : __Result {
	return constraintGroup(Set{
		constraint("true","action must not be query",self,
			true, null),
		__valid()
	});
}

query expressions::Condition::callAllCode() {
	self.validate_expressions__Condition();
	return;
}
query expressions::Condition::validate() : __Result {
	return constraintGroup(Set{
		self.validate_expressions__Condition()
	});
}
query expressions::Condition::validate_expressions__Condition() : __Result {
	return constraintGroup(Set{
		constraint("true","condition must be boolean expression",self,
			true, null),
		__valid()
	});
}


// saclasses

query saclasses::SAClass::callAllCode() {
	self.validate_saclasses__SAClass();
	self.validate_kernel__Namespace();
	self.validate_kernel__InheritableElement();
	self.validate_kernel__PackageableElement();
	self.validate_kernel__NamedElement();
	self.validate_kernel__Class();
	self.derivedFeatures_kernel__InheritableElement();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedFeatures_kernel__Class();
	self.derivedOperation_saclasses__SAClass__getStateMachine();
	self.derivedOperation_saclasses__SAClass__allStateAwareOperations();
	self.derivedOperation_kernel__Namespace__membersAreDistinguishable();
	self.derivedOperation_kernel__InheritableElement__allParents();
	self.derivedOperation_kernel__InheritableElement__membersAreDistinguishable();
	self.derivedOperation_kernel__TemplateableElement__getAllTypeParameters();
	self.derivedOperation_kernel__TemplateableElement__hasTypeParameters();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	self.derivedOperation_kernel__Class__isNative();
	self.derivedOperation_kernel__Class__isNativeNotPrimitive();
	self.derivedOperation_kernel__Class__isPrimitive();
	self.derivedOperation_kernel__Class__isObjectType();
	self.derivedOperation_kernel__Class__getEnclosingElement();
	self.derivedOperation_kernel__Class__getVisibleProperties();
	self.derivedOperation_kernel__Class__getAllVisibleProperties();
	self.derivedOperation_kernel__Class__allParentClasses();
	self.derivedOperation_kernel__Class__allParentOperations();
	self.derivedOperation_kernel__Class__allParentProperties();
	self.derivedOperation_kernel__Class__allParentParameters();
	self.derivedOperation_kernel__Class__allOperations();
	self.derivedOperation_kernel__Class__getAllSAOperations();
	self.derivedOperation_kernel__Class__getOwnedSAOperations();
	self.derivedOperation_kernel__Class__allProperties();
	self.derivedOperation_kernel__Class__allParameters();
	self.derivedOperation_kernel__Class__allOperators();
	self.derivedOperation_kernel__Class__allPrimitiveOperators();
	self.derivedOperation_kernel__Class__getReferencedClasses();
	return;
}
query saclasses::SAClass::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement(),
		self.validate_kernel__Namespace(),
		self.validate_kernel__InheritableElement(),
		self.validate_kernel__PackageableElement(),
		self.validate_kernel__Class(),
		self.validate_saclasses__SAClass()
	});
}
query saclasses::SAClass::validate_saclasses__SAClass() : __Result {
	return constraintGroup(Set{
		constraint("self.allOperations()->includesAll(self.allStateAwareOperations())",null,self,
			self.allOperations()->includesAll(self.allStateAwareOperations()), null),
		constraint("self.ownedOperations->includesAll(self.ownedStateAwareOperations)",null,self,
			self.ownedOperations->includesAll(self.ownedStateAwareOperations), null),
		constraint("self.getStateMachine()->notEmpty() implies
			self.hasSuperClass(self.getStateMachine().targetClass)",null,self,
			self.getStateMachine()->notEmpty() implies
			self.hasSuperClass(self.getStateMachine().targetClass), Set{self.getStateMachine().targetClass}->union(self.parentClasses)),
		constraint("(not self.isAbstract and self.getStateMachine()->isEmpty()) implies self.allStateAwareOperations()->isEmpty()",null,self,
			(not self.isAbstract and self.getStateMachine()->isEmpty()) implies self.allStateAwareOperations()->isEmpty(), null),
		constraint("not self.isNative()",null,self,
			not self.isNative(), null),
		__valid()
	});
}
helper saclasses::SAClass::derivedOperation_saclasses__SAClass__getStateMachine(
) : StateMachine
{
	return if self.machineInitiator->notEmpty() then
						self.machineInitiator.referencedMachine
					else
						null
					endif;
}
helper saclasses::SAClass::derivedOperation_saclasses__SAClass__allStateAwareOperations(
) : Set(Operation)
{
	return self.ownedStateAwareOperations->union(
						self.allParentClasses()->select(oclIsKindOf(saclasses::SAClass))
						.oclAsType(saclasses::SAClass).ownedStateAwareOperations->asSet()
					);
}




// sm
query sm::StateMachine::callAllCode() {
	self.validate_kernel__Namespace();
	self.validate_kernel__InheritableElement();
	self.validate_kernel__PackageableElement();
	self.validate_sm__StateMachine();
	self.validate_kernel__NamedElement();
	self.validate_kernel__Class();
	self.derivedFeatures_kernel__InheritableElement();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedFeatures_kernel__Class();
	self.derivedOperation_kernel__Namespace__membersAreDistinguishable();
	self.derivedOperation_kernel__InheritableElement__allParents();
	self.derivedOperation_kernel__InheritableElement__membersAreDistinguishable();
	self.derivedOperation_kernel__TemplateableElement__getAllTypeParameters();
	self.derivedOperation_kernel__TemplateableElement__hasTypeParameters();
	self.derivedOperation_sm__StateMachine__parentMachines();
	self.derivedOperation_sm__StateMachine__getStateMachine();
	self.derivedOperation_sm__StateMachine__allStateAwareOperations();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	self.derivedOperation_kernel__Class__isNative();
	self.derivedOperation_kernel__Class__isNativeNotPrimitive();
	self.derivedOperation_kernel__Class__isPrimitive();
	self.derivedOperation_kernel__Class__isObjectType();
	self.derivedOperation_kernel__Class__getEnclosingElement();
	self.derivedOperation_kernel__Class__getVisibleProperties();
	self.derivedOperation_kernel__Class__getAllVisibleProperties();
	self.derivedOperation_kernel__Class__allParentClasses();
	self.derivedOperation_kernel__Class__allParentOperations();
	self.derivedOperation_kernel__Class__allParentProperties();
	self.derivedOperation_kernel__Class__allParentParameters();
	self.derivedOperation_kernel__Class__allOperations();
	self.derivedOperation_kernel__Class__getAllSAOperations();
	self.derivedOperation_kernel__Class__getOwnedSAOperations();
	self.derivedOperation_kernel__Class__allProperties();
	self.derivedOperation_kernel__Class__allParameters();
	self.derivedOperation_kernel__Class__allOperators();
	self.derivedOperation_kernel__Class__allPrimitiveOperators();
	self.derivedOperation_kernel__Class__getReferencedClasses();
	return;
}
query sm::StateMachine::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement(),
		self.validate_kernel__Namespace(),
		self.validate_kernel__InheritableElement(),
		self.validate_kernel__PackageableElement(),
		self.validate_kernel__Class(),
		self.validate_sm__StateMachine()
	});
}
query sm::StateMachine::validate_sm__StateMachine() : __Result {
	return constraintGroup(Set{
		constraint("self.parents->isEmpty()","Not implemented yet for state machines",self,
			self.parents->isEmpty(), null),
		constraint("self.allOperations()->includesAll(self.allStateAwareOperations())",null,self,
			self.allOperations()->includesAll(self.allStateAwareOperations()), null),
		constraint("self.ownedOperations->includesAll(self.ownedStateAwareOperations)",null,self,
			self.ownedOperations->includesAll(self.ownedStateAwareOperations), null),
		constraint("self.operationBodies->isUnique(operation)",null,self,
			self.operationBodies->isUnique(operation), null),
		constraint("self.operationBodies.operation->forAll(
			op | self.getAllSAOperations()->includes(op)
					or self.targetClass.getAllSAOperations()->includes(op)
		)",null,self,
			self.operationBodies.operation->forAll(
			op | self.getAllSAOperations()->includes(op)
					or self.targetClass.getAllSAOperations()->includes(op)
		), null),
		__valid()
	});
}
helper sm::StateMachine::derivedOperation_sm__StateMachine__parentMachines(
) : Set(StateMachine)
{
	return self.parents.oclAsType(StateMachine)->asSet();
}
helper sm::StateMachine::derivedOperation_sm__StateMachine__getStateMachine(
) : StateMachine
{
	return self;
}
helper sm::StateMachine::derivedOperation_sm__StateMachine__allStateAwareOperations(
) : Set(Operation)
{
	return self.ownedStateAwareOperations->union(
					self.allParentClasses()->select(oclIsKindOf(saclasses::SAOperationsOwner))
					.oclAsType(saclasses::SAOperationsOwner).ownedStateAwareOperations->asSet()
				);
}


query sm::Patch::callAllCode() {
	self.validate_kernel__Namespace();
	self.validate_kernel__NamedElement();
	self.validate_sm__Patch();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedFeatures_sm__Patch();
	self.derivedOperation_kernel__Namespace__membersAreDistinguishable();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	self.derivedOperation_sm__Patch__revisionEnabledStates();
	self.derivedOperation_sm__Patch__revisionEnabledTransitions();
	self.derivedOperation_sm__Patch__parentCorrespondingPatches();
	self.derivedOperation_sm__Patch__allEnabledSockets();
	self.derivedOperation_sm__Patch__allEnabledEntrySockets();
	self.derivedOperation_sm__Patch__allEnabledExitSockets();
	self.derivedOperation_sm__Patch__allEnabledStates();
	self.derivedOperation_sm__Patch__allEnabledTransitions();
	self.derivedOperation_sm__Patch__allDisabledStates();
	self.derivedOperation_sm__Patch__allDisabledTransitions();
	self.derivedOperation_sm__Patch__allEnabledTargetNodes();
	self.derivedOperation_sm__Patch__allEnabledSourceNodes();
	return;
}
query sm::Patch::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement(),
		self.validate_kernel__Namespace(),
		self.validate_sm__Patch()
	});
}
query sm::Patch::validate_sm__Patch() : __Result {
	return constraintGroup(Set{
		constraint("self.allEnabledTransitions()->forAll(et |
				let allEnabledStates = self.allEnabledStates() in
				allEnabledStates->exists(es |
					(es = et.source.toState() or es.redefines(et.source.toState())) and
					/*not es.oclIsKindOf(FinalState) and*/
					(et.isInterrupting implies es.oclIsKindOf(CompositeState))
				) and
				allEnabledStates->exists(es |
					es = et.target.toState() or	es.redefines(et.target.toState())
				)
			)",null,self,
			self.allEnabledTransitions()->forAll(et |
				let allEnabledStates = self.allEnabledStates() in
				allEnabledStates->exists(es |
					(es = et.source.toState() or es.redefines(et.source.toState())) and
					/*not es.oclIsKindOf(FinalState) and*/
					(et.isInterrupting implies es.oclIsKindOf(CompositeState))
				) and
				allEnabledStates->exists(es |
					es = et.target.toState() or	es.redefines(et.target.toState())
				)
			), null),
		constraint("self.memberSockets->select(ip | ip.isEntry() and
				ip.oclAsType(EntrySocket).isDefault)->size() = 1",null,self,
			self.memberSockets->select(ip | ip.isEntry() and
				ip.oclAsType(EntrySocket).isDefault)->size() = 1, null),
		__valid()
	});
}
helper sm::Patch::derivedFeatures_sm__Patch() {
	var memberNodes_oclValue : Set(Node) := let states : Set(State) = self.memberStates in
				let cstates : Set(CompositeState) = states->select(oclIsKindOf(CompositeState))
								.oclAsType(CompositeState)->asSet() in
				states.oclAsType(Node)->asSet()->union(
					cstates.ownedEntryGates->asSet()
				)->union(
					cstates.ownedExitGates->asSet()
				)
				;
	var inheritedSockets_oclValue : Set(Socket) := self.parentCorrespondingPatches()->collect(p |
					p.memberSockets->reject(iip |
						self.revisionSockets->exists(rip | rip.redefines(iip))
					)
				)->asSet();
	var inheritedSyncPoints_oclValue : Set(SyncPoint) := self.parentCorrespondingPatches()->collect(p |
					p.memberSyncPoints->reject(isp |
						self.addedSyncPoints->exists(asp | asp.redefines(isp))
					)
				)->asSet();
	var inheritedStates_oclValue : Set(State) := self.parentCorrespondingPatches()->collect(p |
					p.memberStates->reject(is | self.revisionStates->exists(rs | rs.redefines(is)))
				)->asSet();
	var inheritedTransitions_oclValue : OrderedSet(Transition) := self.parentCorrespondingPatches()->collect(p |
					p.memberTransitions->reject(it |
						self.revisionTransitions->exists(rt | rt.redefines(it))
					)
				)->asOrderedSet();
	var allEnabledSourceNodesDrv_oclValue : Set(Node) := self.allEnabledSourceNodes();
	var allEnabledTargetNodesDrv_oclValue : Set(Node) := self.allEnabledTargetNodes();
	return;
}
helper sm::Patch::derivedOperation_sm__Patch__revisionEnabledStates(
) : Set(State)
{
	return self.revisionStates - self.revisionDisabledStates();
}
helper sm::Patch::derivedOperation_sm__Patch__revisionEnabledTransitions(
) : OrderedSet(Transition)
{
	return self.libOCL().stableMinus(self.revisionTransitions,self.revisionDisabledTransitions())
				.oclAsType(Transition)->asOrderedSet();
}
helper sm::Patch::derivedOperation_sm__Patch__parentCorrespondingPatches(
) : Set(Patch)
{
	return self.stateMachine.parentMachines()->collect(psm |
					self.owningPatchSet.correspondingPatch(psm)
				)->asSet();
}
helper sm::Patch::derivedOperation_sm__Patch__allEnabledSockets(
) : Set(Socket)
{
	return self.memberSockets;
}
helper sm::Patch::derivedOperation_sm__Patch__allEnabledEntrySockets(
) : Set(EntrySocket)
{
	return self.memberSockets->select(s | s.oclIsKindOf(EntrySocket))
			.oclAsType(EntrySocket)->asSet();
}
helper sm::Patch::derivedOperation_sm__Patch__allEnabledExitSockets(
) : Set(ExitSocket)
{
	return self.memberSockets->select(s | s.oclIsKindOf(ExitSocket))
			.oclAsType(ExitSocket)->asSet();
}
helper sm::Patch::derivedOperation_sm__Patch__allEnabledStates(
) : Set(State)
{
	return self.memberStates - self.allDisabledStates();
}
helper sm::Patch::derivedOperation_sm__Patch__allEnabledTransitions(
) : OrderedSet(Transition)
{
	return self.libOCL().stableMinus(self.memberTransitions,self.allDisabledTransitions())
				.oclAsType(Transition)->asOrderedSet();
}
helper sm::Patch::derivedOperation_sm__Patch__allDisabledStates(
) : Set(State)
{
	return self.revisionDisabledStates()->union(
					self.parentCorrespondingPatches()->collect(pcp |
						pcp.allDisabledStates()
					)->asOrderedSet()
				);
}
helper sm::Patch::derivedOperation_sm__Patch__allDisabledTransitions(
) : OrderedSet(Transition)
{
	return self.revisionDisabledTransitions()->union(
					self.parentCorrespondingPatches()->collect(pcp |
						pcp.allDisabledTransitions()
					)->asOrderedSet()
				)->asOrderedSet();
}
helper sm::Patch::derivedOperation_sm__Patch__allEnabledTargetNodes(
) : Set(Node)
{
	return let states : Set(Node) = self.allEnabledStates() in
				states->union(
					states->select(oclIsKindOf(CompositeState)).oclAsType(CompositeState)
						.ownedEntryGates->asSet()
				)
		;
}
helper sm::Patch::derivedOperation_sm__Patch__allEnabledSourceNodes(
) : Set(Node)
{
	return let states : Set(Node) = self.allEnabledStates() in
				states->union(
					states->select(oclIsKindOf(CompositeState)).oclAsType(CompositeState)
						.ownedExitGates->asSet()
				)
		;
}


query sm::InitialPatch::callAllCode() {
	self.validate_kernel__Namespace();
	self.validate_kernel__NamedElement();
	self.validate_sm__Patch();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedFeatures_sm__Patch();
	self.derivedOperation_kernel__Namespace__membersAreDistinguishable();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	self.derivedOperation_sm__Patch__revisionEnabledStates();
	self.derivedOperation_sm__Patch__revisionEnabledTransitions();
	self.derivedOperation_sm__Patch__parentCorrespondingPatches();
	self.derivedOperation_sm__Patch__allEnabledSockets();
	self.derivedOperation_sm__Patch__allEnabledEntrySockets();
	self.derivedOperation_sm__Patch__allEnabledExitSockets();
	self.derivedOperation_sm__Patch__allEnabledStates();
	self.derivedOperation_sm__Patch__allEnabledTransitions();
	self.derivedOperation_sm__Patch__allDisabledStates();
	self.derivedOperation_sm__Patch__allDisabledTransitions();
	self.derivedOperation_sm__Patch__allEnabledTargetNodes();
	self.derivedOperation_sm__Patch__allEnabledSourceNodes();
	self.derivedOperation_sm__InitialPatch__revisionDisabledStates();
	self.derivedOperation_sm__InitialPatch__revisionDisabledTransitions();
	return;
}
query sm::InitialPatch::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement(),
		self.validate_kernel__Namespace(),
		self.validate_sm__Patch(),
		__valid()
	});
}
helper sm::InitialPatch::derivedOperation_sm__InitialPatch__revisionDisabledStates(
) : Set(State)
{
	return Set{};
}
helper sm::InitialPatch::derivedOperation_sm__InitialPatch__revisionDisabledTransitions(
) : OrderedSet(Transition)
{
	return OrderedSet{};
}


query sm::SucceedingPatch::callAllCode() {
	self.validate_kernel__Namespace();
	self.validate_kernel__PackageableElement();
	self.validate_kernel__NamedElement();
	self.validate_sm__Patch();
	self.validate_sm__SucceedingPatch();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedFeatures_sm__Patch();
	self.derivedFeatures_sm__SucceedingPatch();
	self.derivedOperation_kernel__Namespace__membersAreDistinguishable();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	self.derivedOperation_sm__Patch__revisionEnabledStates();
	self.derivedOperation_sm__Patch__revisionEnabledTransitions();
	self.derivedOperation_sm__Patch__parentCorrespondingPatches();
	self.derivedOperation_sm__Patch__allEnabledSockets();
	self.derivedOperation_sm__Patch__allEnabledEntrySockets();
	self.derivedOperation_sm__Patch__allEnabledExitSockets();
	self.derivedOperation_sm__Patch__allEnabledStates();
	self.derivedOperation_sm__Patch__allEnabledTransitions();
	self.derivedOperation_sm__Patch__allDisabledStates();
	self.derivedOperation_sm__Patch__allDisabledTransitions();
	self.derivedOperation_sm__Patch__allEnabledTargetNodes();
	self.derivedOperation_sm__Patch__allEnabledSourceNodes();
	self.derivedOperation_sm__SucceedingPatch__revisionDisabledStates();
	self.derivedOperation_sm__SucceedingPatch__revisionDisabledTransitions();
	return;
}
query sm::SucceedingPatch::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement(),
		self.validate_kernel__Namespace(),
		self.validate_sm__Patch(),
		self.validate_kernel__PackageableElement(),
		self.validate_sm__SucceedingPatch()
	});
}
query sm::SucceedingPatch::validate_sm__SucceedingPatch() : __Result {
	return constraintGroup(Set{
		constraint("self.precedingPatch.revisionEnabledStates()->
				includesAll(self.disabledStates)","Cannot disable already disabled state.",self,
			self.precedingPatch.revisionEnabledStates()->
				includesAll(self.disabledStates), null),
		constraint("self.precedingPatch.revisionDisabledStates()->
				includesAll(self.enabledStates)","Cannot reenable already enabled state.",self,
			self.precedingPatch.revisionDisabledStates()->
				includesAll(self.enabledStates), null),
		constraint("self.precedingPatch.revisionEnabledTransitions()->
				includesAll(self.disabledTransitions)","Cannot disable already disabled transition.",self,
			self.precedingPatch.revisionEnabledTransitions()->
				includesAll(self.disabledTransitions), null),
		constraint("self.precedingPatch.revisionDisabledTransitions()->
				includesAll(self.enabledTransitions)","Cannot reenable already enabled transition.",self,
			self.precedingPatch.revisionDisabledTransitions()->
				includesAll(self.enabledTransitions), null),
		__valid()
	});
}
helper sm::SucceedingPatch::derivedFeatures_sm__SucceedingPatch() {
	var patchedMachine_oclValue : StateMachine := self.precedingPatch.stateMachine;
	var importedSockets_oclValue : Set(Socket) := self.precedingPatch.revisionSockets->reject(rip |
					self.addedSockets->exists(aip | aip.redefines(rip))
				);
	var importedSyncPoints_oclValue : Set(SyncPoint) := self.precedingPatch.revisionSyncPoints->reject(rsp |
					self.addedStates->exists(asp | asp.redefines(rsp))
				);
	var importedStates_oclValue : Set(State) := self.precedingPatch.revisionStates->reject(rs |
					self.addedStates->exists(as | as.redefines(rs))
				);
	var importedTransitions_oclValue : Set(Transition) := self.precedingPatch.revisionTransitions->reject(rt |
					self.addedStates->exists(at | at.redefines(rt))
				);
	return;
}
helper sm::SucceedingPatch::derivedOperation_sm__SucceedingPatch__revisionDisabledStates(
) : Set(State)
{
	return self.precedingPatch.revisionDisabledStates()->union(self.disabledStates)
					- self.enabledStates;
}
helper sm::SucceedingPatch::derivedOperation_sm__SucceedingPatch__revisionDisabledTransitions(
) : Set(Transition)
{
	return self.precedingPatch.revisionDisabledTransitions()->union(self.disabledTransitions)
					- self.enabledTransitions;
}


query sm::Socket::callAllCode() {
	self.validate_kernel__RedefinableElement();
	self.validate_kernel__NamedElement();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedFeatures_sm__Socket();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	self.derivedOperation_sm__Socket__isExit();
	return;
}
query sm::Socket::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement(),
		self.validate_kernel__RedefinableElement(),
		__valid()
	});
}
helper sm::Socket::derivedFeatures_sm__Socket() {
	var stateMachine_oclValue : StateMachine := self.introducingPatch.stateMachine;
	return;
}
helper sm::Socket::derivedOperation_sm__Socket__isExit(
) : EBoolean
{
	return not self.isEntry();
}
helper sm::Socket::derivedOperation_sm__Socket__isRedefinableBy(
	redefinee : RedefinableElement
) : EBooleanObject
{
	return redefinee.name = self.name and
				redefinee.oclIsTypeOf(Socket) and
				let socket = redefinee.oclAsType(Socket) in
					socket.introducingPatch.revisionSockets->includes(self) or
					socket.stateMachine.allParents()->includes(self.stateMachine);
}


query sm::EntrySocket::callAllCode() {
	self.validate_kernel__RedefinableElement();
	self.validate_sm__EntrySocket();
	self.validate_kernel__NamedElement();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedFeatures_sm__Socket();
	self.derivedOperation_sm__EntrySocket__isEntry();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	self.derivedOperation_sm__Socket__isExit();
	return;
}
query sm::EntrySocket::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement(),
		self.validate_kernel__RedefinableElement(),
		self.validate_sm__EntrySocket()
	});
}
query sm::EntrySocket::validate_sm__EntrySocket() : __Result {
	return constraintGroup(Set{
		constraint("self.entryNode.oclIsKindOf(State) or self.entryNode.oclIsKindOf(EntryGate)",null,self,
			self.entryNode.oclIsKindOf(State) or self.entryNode.oclIsKindOf(EntryGate), null),
		constraint("self.introducingPatch.memberNodes->includes(self.entryNode)",null,self,
			self.introducingPatch.memberNodes->includes(self.entryNode), null),
		__valid()
	});
}
helper sm::EntrySocket::derivedOperation_sm__EntrySocket__isEntry(
) : EBoolean
{
	return true;
}


query sm::ExitSocket::callAllCode() {
	self.validate_sm__ExitSocket();
	self.validate_kernel__RedefinableElement();
	self.validate_kernel__NamedElement();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedFeatures_sm__Socket();
	self.derivedOperation_sm__ExitSocket__isEntry();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	self.derivedOperation_sm__Socket__isExit();
	return;
}
query sm::ExitSocket::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement(),
		self.validate_kernel__RedefinableElement(),
		self.validate_sm__ExitSocket()
	});
}
query sm::ExitSocket::validate_sm__ExitSocket() : __Result {
	return constraintGroup(Set{
		constraint("self.exitNodes->forAll(node |
				node.oclIsKindOf(State) or node.oclIsKindOf(ExitGate)
			)",null,self,
			self.exitNodes->forAll(node |
				node.oclIsKindOf(State) or node.oclIsKindOf(ExitGate)
			), null),
		constraint("self.introducingPatch.memberNodes->includesAll(self.exitNodes)",null,self,
			self.introducingPatch.memberNodes->includesAll(self.exitNodes), null),
		__valid()
	});
}
helper sm::ExitSocket::derivedOperation_sm__ExitSocket__isEntry(
) : EBoolean
{
	return false;
}


query sm::SyncPoint::callAllCode() {
	self.validate_kernel__RedefinableElement();
	self.validate_kernel__NamedElement();
	self.derivedFeatures_sm__SyncPoint();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	return;
}
query sm::SyncPoint::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement(),
		self.validate_kernel__RedefinableElement(),
		__valid()
	});
}
helper sm::SyncPoint::derivedFeatures_sm__SyncPoint() {
	var stateMachine_oclValue : StateMachine := self.introducingPatch.stateMachine;
	return;
}
helper sm::SyncPoint::derivedOperation_sm__SyncPoint__isRedefinableBy(
	redefinee : RedefinableElement
) : EBooleanObject
{
	return redefinee.name = self.name and
				redefinee.oclIsTypeOf(SyncPoint) and
				let point = redefinee.oclAsType(SyncPoint) in
					point.introducingPatch.revisionSyncPoints->includes(self) or
					point.stateMachine.allParents()->includes(self.stateMachine);
}


query sm::Node::callAllCode() {
	self.validate_kernel__NamedElement();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	return;
}
query sm::Node::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement(),
		__valid()
	});
}

query sm::Transition::callAllCode() {
	self.validate_kernel__RedefinableElement();
	self.validate_kernel__NamedElement();
	self.validate_sm__Transition();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedFeatures_sm__Transition();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	return;
}
query sm::Transition::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement(),
		self.validate_kernel__RedefinableElement(),
		self.validate_sm__Transition()
	});
}
query sm::Transition::validate_sm__Transition() : __Result {
	return constraintGroup(Set{
		constraint("self.introducingPatch.allEnabledStates()->includes(self.source.toState())",null,self,
			self.introducingPatch.allEnabledStates()->includes(self.source.toState()), null),
		constraint("self.introducingPatch.allEnabledStates()->includes(self.target.toState())",null,self,
			self.introducingPatch.allEnabledStates()->includes(self.target.toState()), null),
		constraint("self.redefinedTransition->notEmpty() implies self.definedSource->isEmpty()",null,self,
			self.redefinedTransition->notEmpty() implies self.definedSource->isEmpty(), null),
		constraint("self.redefinedTransition->isEmpty() implies self.definedTarget->notEmpty()",null,self,
			self.redefinedTransition->isEmpty() implies self.definedTarget->notEmpty(), null),
		constraint("self.isSuspending implies self.isInterrupting",null,self,
			self.isSuspending implies self.isInterrupting, null),
		constraint("self.isInterrupting implies self.source.oclIsKindOf(CompositeState)",null,self,
			self.isInterrupting implies self.source.oclIsKindOf(CompositeState), null),
		constraintWeak("self.isInterrupting implies (self.guard->notEmpty() or self.trigger->notEmpty())","Interrupting transition should have a guard or trigger",self,
			self.isInterrupting implies (self.guard->notEmpty() or self.trigger->notEmpty()), null),
		__valid()
	});
}
helper sm::Transition::derivedFeatures_sm__Transition() {
	var stateMachine_oclValue : StateMachine := self.introducingPatch.stateMachine;
	var source_oclValue : Node := if self.definedSource->notEmpty() then
					self.definedSource
				else
					self.redefinedTransition.source
				endif;
	var target_oclValue : Node := if self.definedTarget->notEmpty() then
					self.definedTarget
				else
					self.redefinedTransition.target
				endif;
	return;
}
helper sm::Transition::derivedOperation_sm__Transition__isRedefinableBy(
	redefinee : RedefinableElement
) : EBooleanObject
{
	return redefinee.name = self.name and
				redefinee.oclIsTypeOf(Transition) and
				let transition = redefinee.oclAsType(Transition) in
					transition.introducingPatch.revisionEnabledTransitions()->includes(self) or
					transition.stateMachine.allParents()->includes(self.stateMachine);
}



query sm::State::callAllCode() {
	self.validate_kernel__RedefinableElement();
	self.validate_kernel__NamedElement();
	self.validate_sm__State();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedFeatures_sm__State();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	self.derivedOperation_sm__State__toState();
	return;
}
query sm::State::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement(),
		self.validate_kernel__RedefinableElement(),
		self.validate_sm__State()
	});
}
query sm::State::validate_sm__State() : __Result {
	return constraintGroup(Set{
		constraint("self.operationBodies.operation->forAll(
			op | self.stateMachine.getAllSAOperations()->includes(op)
					or self.stateMachine.targetClass.getAllSAOperations()->includes(op)
		)",null,self,
			self.operationBodies.operation->forAll(
			op | self.stateMachine.getAllSAOperations()->includes(op)
					or self.stateMachine.targetClass.getAllSAOperations()->includes(op)
		), null),
		constraint("self.operationBodies->isUnique(operation)",null,self,
			self.operationBodies->isUnique(operation), null),
		__valid()
	});
}
helper sm::State::derivedFeatures_sm__State() {
	var stateMachine_oclValue : StateMachine := self.introducingPatch.stateMachine;
	return;
}
helper sm::State::derivedOperation_sm__State__isRedefinableBy(
	redefinee : RedefinableElement
) : EBooleanObject
{
	return redefinee.name = self.name and
				redefinee.oclIsKindOf(State) and
				let state = redefinee.oclAsType(State) in
					state.stateMachine.allParents()->includes(self.stateMachine) or
					state.introducingPatch.revisionEnabledStates()->includes(self);
}
helper sm::State::derivedOperation_sm__State__toState(
) : State
{
	return self;
}


query sm::CompositeState::callAllCode() {
	self.validate_kernel__RedefinableElement();
	self.validate_sm__CompositeState();
	self.validate_kernel__Namespace();
	self.validate_kernel__NamedElement();
	self.validate_sm__State();
	self.derivedFeatures_sm__CompositeState();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedFeatures_sm__State();
	self.derivedOperation_kernel__Namespace__membersAreDistinguishable();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	self.derivedOperation_sm__State__toState();
	return;
}
query sm::CompositeState::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement(),
		self.validate_kernel__RedefinableElement(),
		self.validate_sm__State(),
		self.validate_kernel__Namespace(),
		self.validate_sm__CompositeState()
	});
}
query sm::CompositeState::validate_sm__CompositeState() : __Result {
	return constraintGroup(Set{
		constraint("self.submachines->includesAll(self.ownedMachines)",null,self,
			self.submachines->includesAll(self.ownedMachines), null),
		constraint("self.machineReferences->isUnique(alias)",null,self,
			self.machineReferences->isUnique(alias), null),
		__valid()
	});
}
helper sm::CompositeState::derivedFeatures_sm__CompositeState() {
	var submachines_oclValue : OrderedSet(StateMachine) := self.machineReferences.referencedMachine->asOrderedSet();
	return;
}

query sm::Dependency::callAllCode() {
	self.validate_sm__Dependency();
	return;
}
query sm::Dependency::validate() : __Result {
	return constraintGroup(Set{
		self.validate_sm__Dependency()
	});
}
query sm::Dependency::validate_sm__Dependency() : __Result {
	return constraintGroup(Set{
		constraint("self.syncPoints->forAll(sp | self.owningState.submachines->includes(sp.stateMachine))",null,self,
			self.syncPoints->forAll(sp | self.owningState.submachines->includes(sp.stateMachine)), null),
		constraint("self.syncPoints->forAll(sp | self.syncPoints->excluding(sp)->collect(esp |
				esp.stateMachine)->excludes(sp.stateMachine)
			)",null,self,
			self.syncPoints->forAll(sp | self.syncPoints->excluding(sp)->collect(esp |
				esp.stateMachine)->excludes(sp.stateMachine)
			), null),
		__valid()
	});
}

query sm::Gate::callAllCode() {
	self.validate_kernel__NamedElement();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	return;
}
query sm::Gate::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement(),
		__valid()
	});
}


query sm::EntryGateConfiguration::callAllCode() {
	self.validate_sm__EntryGateConfiguration();
	return;
}
query sm::EntryGateConfiguration::validate() : __Result {
	return constraintGroup(Set{
		self.validate_sm__EntryGateConfiguration()
	});
}
query sm::EntryGateConfiguration::validate_sm__EntryGateConfiguration() : __Result {
	return constraintGroup(Set{
		constraint("self.usesHistory implies self.historyLevel->notEmpty() and
				(self.historyLevel > 0 or self.historyLevel = -1)",null,self,
			self.usesHistory implies self.historyLevel->notEmpty() and
				(self.historyLevel > 0 or self.historyLevel = -1), null),
		__valid()
	});
}

query sm::EntryGate::callAllCode() {
	self.validate_sm__EntryGate();
	self.validate_kernel__NamedElement();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedOperation_sm__EntryGate__toState();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	return;
}
query sm::EntryGate::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement(),
		self.validate_sm__EntryGate()
	});
}
query sm::EntryGate::validate_sm__EntryGate() : __Result {
	return constraintGroup(Set{
		constraint("self.configurations.machineReference->asBag() =
			self.owningState.machineReferences->asBag()","Entry gate must reference all state machines (each once)",self,
			self.configurations.machineReference->asBag() =
			self.owningState.machineReferences->asBag(), null),
		__valid()
	});
}
helper sm::EntryGate::derivedOperation_sm__EntryGate__toState(
) : State
{
	return self.owningState;
}



query sm::ExitGate::callAllCode() {
	self.validate_kernel__NamedElement();
	self.validate_sm__ExitGate();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	self.derivedOperation_sm__ExitGate__toState();
	return;
}
query sm::ExitGate::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement(),
		self.validate_sm__ExitGate()
	});
}
query sm::ExitGate::validate_sm__ExitGate() : __Result {
	return constraintGroup(Set{
		constraint("self.configurations.machineReference->asBag() =
			self.owningState.machineReferences->asBag()","Exit gate must reference all state machines (each once)",self,
			self.configurations.machineReference->asBag() =
			self.owningState.machineReferences->asBag(), null),
		__valid()
	});
}
helper sm::ExitGate::derivedOperation_sm__ExitGate__toState(
) : State
{
	return self.owningState;
}



query sm::StateMachineInitiator::callAllCode() {
	self.validate_sm__StateMachineInitiator();
	return;
}
query sm::StateMachineInitiator::validate() : __Result {
	return constraintGroup(Set{
		self.validate_sm__StateMachineInitiator()
	});
}
query sm::StateMachineInitiator::validate_sm__StateMachineInitiator() : __Result {
	return constraintGroup(Set{
		constraint("self.arguments->isUnique(referencedParameter)",null,self,
			self.arguments->isUnique(referencedParameter), null),
		constraint("self.referencedMachine.allParameters()->asBag() = self.arguments.referencedParameter->asBag()",null,self,
			self.referencedMachine.allParameters()->asBag() = self.arguments.referencedParameter->asBag(), null),
		__valid()
	});
}

query sm::StateMachineReference::callAllCode() {
	self.validate_sm__StateMachineReference();
	self.validate_sm__StateMachineInitiator();
	self.derivedOperation_sm__StateMachineReference__getValidEntrySockets();
	self.derivedOperation_sm__StateMachineReference__getValidExitSockets();
	return;
}
query sm::StateMachineReference::validate() : __Result {
	return constraintGroup(Set{
		self.validate_sm__StateMachineInitiator(),
		self.validate_sm__StateMachineReference()
	});
}
query sm::StateMachineReference::validate_sm__StateMachineReference() : __Result {
	return constraintGroup(Set{
		constraintWeak("self.referencedMachine.owningState->isEmpty() or
			self.compositeState.redefines(self.referencedMachine.owningState)",null,self,
			self.referencedMachine.owningState->isEmpty() or
			self.compositeState.redefines(self.referencedMachine.owningState), null),
		constraint("self.referencedMachinePatch->notEmpty() implies
				self.referencedMachinePatch.stateMachine = self.referencedMachine",null,self,
			self.referencedMachinePatch->notEmpty() implies
				self.referencedMachinePatch.stateMachine = self.referencedMachine, null),
		__valid()
	});
}
helper sm::StateMachineReference::derivedOperation_sm__StateMachineReference__getValidEntrySockets(
) : Set(EntrySocket)
{
	return if (self.referencedMachinePatch->notEmpty()) then
					self.referencedMachinePatch.allEnabledEntrySockets()
				else
					self.referencedMachine.initialPatch.allEnabledEntrySockets()
				endif;
}
helper sm::StateMachineReference::derivedOperation_sm__StateMachineReference__getValidExitSockets(
) : Set(ExitSocket)
{
	return if (self.referencedMachinePatch->notEmpty()) then
					self.referencedMachinePatch.allEnabledExitSockets()
				else
					self.referencedMachine.initialPatch.allEnabledExitSockets()
				endif;
}



// migrations
query migrations::PatchSet::callAllCode() {
	self.validate_kernel__Namespace();
	self.validate_kernel__PackageableElement();
	self.validate_migrations__PatchSet();
	self.validate_kernel__NamedElement();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedOperation_kernel__Namespace__membersAreDistinguishable();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	return;
}
query migrations::PatchSet::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement(),
		self.validate_kernel__Namespace(),
		self.validate_kernel__PackageableElement(),
		self.validate_migrations__PatchSet()
	});
}
query migrations::PatchSet::validate_migrations__PatchSet() : __Result {
	return constraintGroup(Set{
		constraint("self.patches->forAll(p | p.owningPatchSet = self)",null,self,
			self.patches->forAll(p | p.owningPatchSet = self), null),
		constraint("self.migration->notEmpty() implies	self.migration.patchSets->includes(self)",null,self,
			self.migration->notEmpty() implies	self.migration.patchSets->includes(self), null),
		constraint("self.patches->forAll(p | self.patches->excluding(p)->collect(ep |
					ep.stateMachine
				)->excludes(p.stateMachine))",null,self,
			self.patches->forAll(p | self.patches->excluding(p)->collect(ep |
					ep.stateMachine
				)->excludes(p.stateMachine)), null),
		__valid()
	});
}
helper migrations::PatchSet::derivedOperation_migrations__PatchSet__correspondingPatch(
	stateMachine : StateMachine
) : Patch
{
	return let patch = self.findPatchFor(stateMachine) in
						if patch->notEmpty() then
							patch
						else
							self.migration.correspondingPatch(stateMachine)
						endif;
}
helper migrations::PatchSet::derivedOperation_migrations__PatchSet__findPatchFor(
	stateMachine : StateMachine
) : Patch
{
	return self.patches->any(p | p.stateMachine = stateMachine);
}


query migrations::Migration::callAllCode() {
	self.validate_kernel__Namespace();
	self.validate_kernel__PackageableElement();
	self.validate_kernel__NamedElement();
	self.validate_migrations__Migration();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedOperation_kernel__Namespace__membersAreDistinguishable();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	return;
}
query migrations::Migration::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement(),
		self.validate_kernel__Namespace(),
		self.validate_kernel__PackageableElement(),
		self.validate_migrations__Migration()
	});
}
query migrations::Migration::validate_migrations__Migration() : __Result {
	return constraintGroup(Set{
		constraint("self.patchSets->forAll(ps | ps.migration = self)",null,self,
			self.patchSets->forAll(ps | ps.migration = self), null),
		constraint("let patches = self.patchSets->collect(ps | ps.patches) in
				patches->forAll(p | patches->excluding(p)->collect(
					ep | ep.stateMachine
				)->excludes(p.stateMachine))",null,self,
			let patches = self.patchSets->collect(ps | ps.patches) in
				patches->forAll(p | patches->excluding(p)->collect(
					ep | ep.stateMachine
				)->excludes(p.stateMachine)), null),
		__valid()
	});
}
helper migrations::Migration::derivedOperation_migrations__Migration__correspondingPatch(
	stateMachine : StateMachine
) : Patch
{
	return let patch = self.patchSets->iterate(ps; res : Patch = null |
						let fp = ps.findPatchFor(stateMachine) in
							if fp->notEmpty() then fp else res endif
					) in
						if patch->isEmpty()	and self.precedingMigration->notEmpty() then
							self.precedingMigration.correspondingPatch(stateMachine)
						else
							patch
						endif;
}


query migrations::MigrationTransition::callAllCode() {
	self.validate_kernel__RedefinableElement();
	self.validate_kernel__NamedElement();
	self.validate_sm__Transition();
	self.derivedFeatures_kernel__NamedElement();
	self.derivedFeatures_sm__Transition();
	self.derivedOperation_kernel__NamedElement__allNamespaces();
	return;
}
query migrations::MigrationTransition::validate() : __Result {
	return constraintGroup(Set{
		self.validate_kernel__NamedElement(),
		self.validate_kernel__RedefinableElement(),
		self.validate_sm__Transition(),
		__valid()
	});
}


// extensions
query extensions::Extension::callAllCode() {
	self.validate_extensions__Extension();
	return;
}
query extensions::Extension::validate() : __Result {
	return constraintGroup(Set{
		self.validate_extensions__Extension()
	});
}
query extensions::Extension::validate_extensions__Extension() : __Result {
	return constraintGroup(Set{
		constraint("self.extensions->isEmpty()",null,self,
			self.extensions->isEmpty(), null),
		__valid()
	});
}

query extensions::ClassExt::callAllCode() {
	self.validate_extensions__Extension();
	return;
}
query extensions::ClassExt::validate() : __Result {
	return constraintGroup(Set{
		self.validate_extensions__Extension(),
		__valid()
	});
}

query extensions::TypedElementExt::callAllCode() {
	self.validate_extensions__Extension();
	return;
}
query extensions::TypedElementExt::validate() : __Result {
	return constraintGroup(Set{
		self.validate_extensions__Extension(),
		__valid()
	});
}

query extensions::PropertyExt::callAllCode() {
	self.validate_extensions__Extension();
	return;
}
query extensions::PropertyExt::validate() : __Result {
	return constraintGroup(Set{
		self.validate_extensions__Extension(),
		__valid()
	});
}

query extensions::PackageableElementExt::callAllCode() {
	self.validate_extensions__Extension();
	return;
}
query extensions::PackageableElementExt::validate() : __Result {
	return constraintGroup(Set{
		self.validate_extensions__Extension(),
		__valid()
	});
}


// dto

query dto::DTOPackageableElement::callAllCode() {
	self.validate_extensions__Extension();
	return;
}
query dto::DTOPackageableElement::validate() : __Result {
	return constraintGroup(Set{
		self.validate_extensions__Extension(),
		__valid()
	});
}

query dto::DTOTypedElement::callAllCode() {
	self.validate_extensions__Extension();
	self.validate_dto__DTOTypedElement();
	return;
}
query dto::DTOTypedElement::validate() : __Result {
	return constraintGroup(Set{
		self.validate_extensions__Extension(),
		self.validate_dto__DTOTypedElement()
	});
}
query dto::DTOTypedElement::validate_dto__DTOTypedElement() : __Result {
	return constraintGroup(Set{
		constraint("self.owningTypedElement.oclIsKindOf(Operation)
			   implies
			   self.owningTypedElement.oclAsType(Operation).isQuery",null,self,
			self.owningTypedElement.oclIsKindOf(Operation)
			   implies
			   self.owningTypedElement.oclAsType(Operation).isQuery, null),
		__valid()
	});
}

query dto::DTOLibrary::callAllCode() {
	self.derivedOperation_dto__DTOLibrary__isTopLevelPackageTranferableByDefault();
	return;
}
helper dto::DTOLibrary::derivedOperation_dto__DTOLibrary__isTopLevelPackageTranferableByDefault(
) : EBoolean
{
	return true;
}
helper dto::DTOLibrary::derivedOperation_dto__DTOLibrary__hasDTOPackageableElement(
	elem : PackageableElement
) : EBoolean
{
	return self.getDTOPackageableElement(elem)->notEmpty();
}
helper dto::DTOLibrary::derivedOperation_dto__DTOLibrary__getDTOPackageableElement(
	elem : PackageableElement
) : DTOPackageableElement
{
	return
			let ext : Sequence(extensions::dto::DTOPackageableElement)
				= elem.extensions->select(oclIsKindOf(extensions::dto::DTOPackageableElement))
					.oclAsType(extensions::dto::DTOPackageableElement)->asSequence() in
			ext->first();
}
helper dto::DTOLibrary::derivedOperation_dto__DTOLibrary__hasDTOTypedElement(
	elem : TypedElement
) : EBoolean
{
	return self.getDTOTypedElement(elem)->notEmpty();
}
helper dto::DTOLibrary::derivedOperation_dto__DTOLibrary__getDTOTypedElement(
	elem : TypedElement
) : DTOTypedElement
{
	return
			let ext : Sequence(extensions::dto::DTOTypedElement)
				= elem.extensions->select(oclIsKindOf(extensions::dto::DTOTypedElement))
					.oclAsType(extensions::dto::DTOTypedElement)->asSequence() in
			ext->first();
}
helper dto::DTOLibrary::derivedOperation_dto__DTOLibrary__isPackageableElemTransferable(
	elem : PackageableElement
) : EBoolean
{
	return let dtoElem : DTOPackageableElement = self.getDTOPackageableElement(elem) in
					if dtoElem->isEmpty() or dtoElem.transferType->isEmpty() or
					dtoElem.transferType = TransferType::inherit then
--						if elem.oclIsKindOf(Class) and elem.oclAsType(Class).parentClasses->notEmpty() then
--							self.isPackageableElemTransferable(elem.oclAsType(Class).parentClasses->asSequence()->first())
--						else
							if elem.owningPackage->notEmpty() then
								self.isPackageableElemTransferable(elem.owningPackage)
							else
								self.isTopLevelPackageTranferableByDefault()
							endif
--						endif
					else
						dtoElem.transferType = TransferType::doTransfer
					endif
			;
}
helper dto::DTOLibrary::derivedOperation_dto__DTOLibrary__isTypedElementTransferable(
	elem : TypedElement
) : EBoolean
{
	return let dtoElem : DTOTypedElement = self.getDTOTypedElement(elem) in
					elem.type->notEmpty() and
					(dtoElem->isEmpty() or not dtoElem.isHidden) and
					(elem.type.isConcrete() implies
						self.isPackageableElemTransferable(elem.type.getConcreteClass())) and
					(elem.oclIsKindOf(kernel::Operation) implies
						(elem.oclAsType(kernel::Operation).isQuery and
						 elem.oclAsType(kernel::Operation).parameters->size() = 0))
			;
}
helper dto::DTOLibrary::derivedOperation_dto__DTOLibrary__getAllTransferableProperties(
	cls : Class
) : Set(Property)
{
	return cls.allProperties()->select(pr | self.isTypedElementTransferable(pr) and pr.isReadable);
}
helper dto::DTOLibrary::derivedOperation_dto__DTOLibrary__getAllTransferableOperations(
	cls : Class
) : Set(Operation)
{
	return cls.allOperations()->select(op | self.isTypedElementTransferable(op));
}
helper dto::DTOLibrary::derivedOperation_dto__DTOLibrary__getOwnedTransferableProperties(
	cls : Class
) : Set(Property)
{
	return cls.ownedProperties->select(pr | self.isTypedElementTransferable(pr));
}
helper dto::DTOLibrary::derivedOperation_dto__DTOLibrary__getOwnedTransferableOperations(
	cls : Class
) : Set(Operation)
{
	return cls.ownedOperations->select(op | self.isTypedElementTransferable(op));
}
helper dto::DTOLibrary::derivedOperation_dto__DTOLibrary__getAllTransferableClasses(
	model : Model
) : Set(Class)
{
	return model.allInstances(kernel::Class).oclAsType(kernel::Class)->select(
				cls | self.isPackageableElemTransferable(cls))->asSet()
			;
}



// serialization
query serialization::ClassSerialization::callAllCode() {
	self.validate_extensions__Extension();
	self.validate_serialization__ClassSerialization();
	self.derivedOperation_serialization__ClassSerialization__getId();
	return;
}
query serialization::ClassSerialization::validate() : __Result {
	return constraintGroup(Set{
		self.validate_extensions__Extension(),
		self.validate_serialization__ClassSerialization()
	});
}
query serialization::ClassSerialization::validate_serialization__ClassSerialization() : __Result {
	return constraintGroup(Set{
		constraint("self.isEmbedded implies
				(self.tableName->isEmpty() and
				 self.inheritanceType = serialization::InheritanceType::__not_defined and
				 self.primaryKeyJoinColumn->isEmpty())",null,self,
			self.isEmbedded implies
				(self.tableName->isEmpty() and
				 self.inheritanceType = serialization::InheritanceType::__not_defined and
				 self.primaryKeyJoinColumn->isEmpty()), null),
		constraint("self.isEmbedded implies self.owningClass.allProperties()->forAll(
					prop | prop.extensions->exists(
						ext | ext.oclIsKindOf(serialization::PropertySerialization)
							  and ext.oclAsType(serialization::PropertySerialization).isEmbedded
					)
				)","Embedded class: There must be defined embedding column name pattern for each property",self,
			self.isEmbedded implies self.owningClass.allProperties()->forAll(
					prop | prop.extensions->exists(
						ext | ext.oclIsKindOf(serialization::PropertySerialization)
							  and ext.oclAsType(serialization::PropertySerialization).isEmbedded
					)
				), null),
		constraint("self.owningClass.allProperties()->forAll(
					prop | prop.libSerialization().hasPropertySerialization(prop)
				)","There must be defined serialization strategy for all properties",self,
			self.owningClass.allProperties()->forAll(
					prop | prop.libSerialization().hasPropertySerialization(prop)
				), null),
		constraint("self.owningClass.allParentClasses()->forAll(
					pc | pc.libSerialization().hasClassSerialization(pc)
				)","There must be defined serialization strategy for all parent classes",self,
			self.owningClass.allParentClasses()->forAll(
					pc | pc.libSerialization().hasClassSerialization(pc)
				), null),
		constraint("not self.owningClass.isNative() and not self.isEmbedded and not self.owningClass.oclIsKindOf(StateMachine)
		  			implies
		       self.owningClass.allProperties()->select(
					prop | prop.libSerialization().hasPropertySerialization(prop)
						and prop.libSerialization().getPropertySerialization(prop).isID
				)->size() = 1","There must be just 1 ID defined for not embedded not native domain class",self,
			not self.owningClass.isNative() and not self.isEmbedded and not self.owningClass.oclIsKindOf(StateMachine)
		  			implies
		       self.owningClass.allProperties()->select(
					prop | prop.libSerialization().hasPropertySerialization(prop)
						and prop.libSerialization().getPropertySerialization(prop).isID
				)->size() = 1, null),
		constraint("self.isEmbedded implies self.owningClass.allParentClasses()->forAll(
					cls | cls.extensions->exists(
						ext | ext.oclIsKindOf(serialization::ClassSerialization)
							  and ext.oclAsType(serialization::ClassSerialization).isEmbedded
					)
				)","Embedded class: All parents must be embedded too",self,
			self.isEmbedded implies self.owningClass.allParentClasses()->forAll(
					cls | cls.extensions->exists(
						ext | ext.oclIsKindOf(serialization::ClassSerialization)
							  and ext.oclAsType(serialization::ClassSerialization).isEmbedded
					)
				), null),
		constraint("self.primaryKeyJoinColumn->notEmpty() implies
				self.primaryKeyJoinColumn.owningClass = self.owningClass",null,self,
			self.primaryKeyJoinColumn->notEmpty() implies
				self.primaryKeyJoinColumn.owningClass = self.owningClass, null),
		constraint("self.owningClass.extensions->select(oclIsKindOf(ClassSerialization))->size() = 1",null,self,
			self.owningClass.extensions->select(oclIsKindOf(ClassSerialization))->size() = 1, null),
		__valid()
	});
}
helper serialization::ClassSerialization::derivedOperation_serialization__ClassSerialization__getId(
) : PropertySerialization
{
	return self.owningClass.allProperties()->collect(p | p.libSerialization().getPropertySerialization(p))
				->select(isID)->asSequence()->first();
}


query serialization::NotEntity::callAllCode() {
	self.validate_extensions__Extension();
	self.validate_serialization__NotEntity();
	return;
}
query serialization::NotEntity::validate() : __Result {
	return constraintGroup(Set{
		self.validate_extensions__Extension(),
		self.validate_serialization__NotEntity()
	});
}
query serialization::NotEntity::validate_serialization__NotEntity() : __Result {
	return constraintGroup(Set{
		constraint("not self.owningClass.extensions->exists(oclIsKindOf(ClassSerialization))",null,self,
			not self.owningClass.extensions->exists(oclIsKindOf(ClassSerialization)), null),
		__valid()
	});
}

query serialization::AttributeOverride::callAllCode() {
	self.validate_serialization__AttributeOverride();
	return;
}
query serialization::AttributeOverride::validate() : __Result {
	return constraintGroup(Set{
		self.validate_serialization__AttributeOverride()
	});
}
query serialization::AttributeOverride::validate_serialization__AttributeOverride() : __Result {
	return constraintGroup(Set{
		constraint("let type : kernel::TypeSpecification = self.serialization.owningProperty.type in
				type.isConcrete() and
				type.getConcreteClass().allProperties()->includes(self.attribute)
	",null,self,
			let type : kernel::TypeSpecification = self.serialization.owningProperty.type in
				type.isConcrete() and
				type.getConcreteClass().allProperties()->includes(self.attribute)
	, null),
		constraint("false","embedded attribute overriding not supported yet",self,
			false, null),
		__valid()
	});
}

query serialization::PropertySerialization::callAllCode() {
	self.validate_extensions__Extension();
	self.validate_serialization__PropertySerialization();
	self.derivedOperation_serialization__PropertySerialization__getReferenceType();
	return;
}
query serialization::PropertySerialization::validate() : __Result {
	return constraintGroup(Set{
		self.validate_extensions__Extension(),
		self.validate_serialization__PropertySerialization()
	});
}
query serialization::PropertySerialization::validate_serialization__PropertySerialization() : __Result {
	return constraintGroup(Set{
		constraint("(self.isTransient or self.isEmbedded) implies
				(self.columnName->isEmpty() and
				 self.indexColumnName->isEmpty() and
				 self.joinColumnName->isEmpty() and
				 not self.isEmbeddingOverridden and
				 not self.isID
			)",null,self,
			(self.isTransient or self.isEmbedded) implies
				(self.columnName->isEmpty() and
				 self.indexColumnName->isEmpty() and
				 self.joinColumnName->isEmpty() and
				 not self.isEmbeddingOverridden and
				 not self.isID
			), null),
		constraint("self.isTransient implies
				(self.fetchType = serialization::FetchType::__not_defined and
				 self.cascadeType->isEmpty()
			)",null,self,
			self.isTransient implies
				(self.fetchType = serialization::FetchType::__not_defined and
				 self.cascadeType->isEmpty()
			), null),
		constraint("self.columnNamePattern->notEmpty() implies self.isEmbedded",null,self,
			self.columnNamePattern->notEmpty() implies self.isEmbedded, null),
		constraint("self.sequenceName->notEmpty() implies self.isID",null,self,
			self.sequenceName->notEmpty() implies self.isID, null),
		constraint("self.attributeOverrides->notEmpty() implies self.isEmbeddingOverridden",null,self,
			self.attributeOverrides->notEmpty() implies self.isEmbeddingOverridden, null),
		constraint("self.owningProperty.extensions->select(oclIsKindOf(PropertySerialization))->size() = 1",null,self,
			self.owningProperty.extensions->select(oclIsKindOf(PropertySerialization))->size() = 1, null),
		constraint("self.owningProperty.owningClass.extensions->exists(
						ext | ext.oclIsKindOf(serialization::ClassSerialization)
			)",null,self,
			self.owningProperty.owningClass.extensions->exists(
						ext | ext.oclIsKindOf(serialization::ClassSerialization)
			), null),
		constraint("self.isID implies self.owningProperty.type.isConcrete()
				and self.owningProperty.type.getConcreteClass().isPrimitive()",null,self,
			self.isID implies self.owningProperty.type.isConcrete()
				and self.owningProperty.type.getConcreteClass().isPrimitive(), null),
		__valid()
	});
}
helper serialization::PropertySerialization::derivedOperation_serialization__PropertySerialization__getReferenceType(
) : ReferenceType
{
	return if self.isEmbedded or self.isTransient or self.isEmbeddingOverridden then
						ReferenceType::__not_defined
					else
						let type : kernel::TypeSpecification = self.owningProperty.type in
						if type.isConcrete() then (
							if type.getConcreteClass().isPrimitive() then
								ReferenceType::basic
							else if type.getConcreteClass().isContainer then
								ReferenceType::oneToMany
							else
								ReferenceType::manyToOne
							endif endif
						) else
							 ReferenceType::manyToOne
						endif
					endif;
}


query serialization::SerializationLibrary::callAllCode() {
	return;
}
helper serialization::SerializationLibrary::derivedOperation_serialization__SerializationLibrary__hasPropertySerialization(
	pr : Property
) : EBooleanObject
{
	return self.getPropertySerialization(pr)->notEmpty();
}
helper serialization::SerializationLibrary::derivedOperation_serialization__SerializationLibrary__hasClassSerialization(
	cls : Class
) : EBooleanObject
{
	return self.getClassSerialization(cls)->notEmpty();
}
helper serialization::SerializationLibrary::derivedOperation_serialization__SerializationLibrary__isNotEntity(
	cls : Class
) : EBooleanObject
{
	return cls.extensions->exists(oclIsKindOf(extensions::serialization::NotEntity));
}
helper serialization::SerializationLibrary::derivedOperation_serialization__SerializationLibrary__getClassSerialization(
	cls : Class
) : ClassSerialization
{
	return
			let ext : Sequence(extensions::serialization::ClassSerialization)
				= cls.extensions->select(oclIsKindOf(extensions::serialization::ClassSerialization))
					.oclAsType(extensions::serialization::ClassSerialization)->asSequence() in
			ext->first();
}
helper serialization::SerializationLibrary::derivedOperation_serialization__SerializationLibrary__getPropertySerialization(
	pr : Property
) : PropertySerialization
{
	return
			let ext : Sequence(extensions::serialization::PropertySerialization)
				= pr.extensions->select(oclIsKindOf(extensions::serialization::PropertySerialization))
					.oclAsType(extensions::serialization::PropertySerialization)->asSequence() in
			ext->first();
}
helper serialization::SerializationLibrary::derivedOperation_serialization__SerializationLibrary__isEmbedded(
	cls : Class
) : EBoolean
{
	return self.hasClassSerialization(cls) and self.getClassSerialization(cls).isEmbedded;
}
helper serialization::SerializationLibrary::derivedOperation_serialization__SerializationLibrary__getSequenceGeneratorProperties(
	ser : ClassSerialization
) : Set(Property)
{
	return
			ser.owningClass.allProperties()->select(pr : kernel::Property |
				self.hasPropertySerialization(pr) and self.getPropertySerialization(pr).sequenceName->notEmpty()
			);
}



/*
 ****************************************
 */

intermediate class __Result {
	nbErrors : Integer;
	nbWarnings : Integer;
}

query __valid() : __Result {
	return object __Result {
		nbErrors := 0;
		nbWarnings := 0;
	}
}

query __error() : __Result {
	return object __Result {
		nbErrors := 1;
		nbWarnings := 0;
	}
}

query __warning() : __Result {
	return object __Result {
		nbErrors := 0;
		nbWarnings := 1;
	}
}

query Stdlib::Model::validateAll() : __Result {
	var res : __Result := constraintGroup(Set{
		constraintGroup(self.objects()->collect(o | o.validate())->asSet()),
		self.validateModelBase()
	});
	if (res.nbErrors + res.nbWarnings = 0) then
		log("Validation> All defined constraints are satisfied")
	else
		log("Validation> " + res.nbErrors.toString() + " error(s) and " + res.nbWarnings.toString() + " warning(s) found!")
	endif;
	return res;
}

query Stdlib::Model::validateModelBase() : __Result {
	return constraintGroup(Set{
		constraint("self.rootObjects()->size() = 1",
			"Model has exactly one root element",null,
			self.rootObjects()->size() = 1, null)
	});
}

// There must be OclAny here for correct polymophism
//		(one would expect that Element is enought, but it does't work)
query OclAny::validate() : __Result {
	// By default, the object satisfy all contraints (if there are no defined)
	return __valid();
}

query constraintGroup(set : Set(__Result)) : __Result {
	return object __Result {
		nbErrors := set.nbErrors->sum();
		nbWarnings := set.nbWarnings->sum();
	}
}

/*
	query constraint(constraint : String, message : String, obj : Element, satisfied : Boolean, values : OclAny) : __Result {
//	log("checking " + constraint + " ...");
	if (not (satisfied = true)) then {	// "null" is bad value, it means the same as "false"
		reportProblem(true,obj,constraint,message,values);
		return __error();
	} endif;
	return __valid();
}
*/

query constraint(constraint : String, message : String, obj : Element, satisfied : Boolean, values : Collection(OclAny)) : __Result {
//	log("checking " + constraint + " ...");
	if (not (satisfied = true)) then {	// "null" is bad value, it means the same as "false"
		reportProblem(true,obj,constraint,message,values);
		return __error();
	} endif;
	return __valid();
}

query constraintWeak(constraint : String, message : String, obj : Element, satisfied : Boolean, values : Collection(OclAny)) : __Result {
//	log("checking " + constraint + " ...");
	if (not (satisfied = true)) then {	// "null" is bad value, it means the same as "false"
		if (showWarnings) then
			reportProblem(false,obj,constraint,message,values)
		endif;
		return __warning();
	} endif;
	return __valid();
}

query reportProblem(isError : Boolean, obj : Element, constraint : String, message : String, values : Collection(OclAny)) : OclVoid {
	log("Validation> " + if (isError) then "ERROR: " else "WARNING: " endif
		+ if (obj != null) then obj.oclAsType(EObject).metaClassName() else "" endif
		+ " [" + constraint +"]" +
		if (message != null) then ": " + message else "" endif + " -- ");
	var iter : Element = obj;
	while(iter != null) {
		log("	" + iter.repr().substringAfter("eu.collectionspro.jam.mm."));
		iter := iter.container();
	};

	if values->notEmpty() then {
		log("	Additional value(s):");
		values->forEach(val) {
			if val.oclIsKindOf(Element) then {
				reportElement(val.oclAsType(Element));
			} else {
				reportAny(val);
			} endif;
			log("	--");
		}
	} endif;
	return null;
}

helper reportAny(value : OclAny) {
	if value.oclIsKindOf(String) then {
		log("		" + value.oclAsType(String));
	} else {
		log("		: ERROR: Unsupported data type");
	} endif
}

helper reportElement(element : Element) {
	var iter : Element = element;
	while(iter != null) {
		log("		" + iter.repr().substringAfter("eu.collectionspro.jam.mm."));
		iter := iter.container();
	};
}

query Stdlib::Model::callAllCode()  {
	self.objects()->collect(o | o.callAllCode());
	return;
}

// OclAny viz validate()
helper OclAny::callAllCode()  {
	return;
}

