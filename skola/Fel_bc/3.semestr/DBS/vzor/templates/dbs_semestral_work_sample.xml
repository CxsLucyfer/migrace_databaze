<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="http://service.felk.cvut.cz/courses/X36DBS/xml/sprojekt_html.xsl"?>
<!DOCTYPE sproject PUBLIC "-//XMLmind//DTD Sprojekt//EN"
"http://service.felk.cvut.cz/courses/X36DBS/xml/sprojekt/sprojekt.dtd">
<sproject>
  <course>
    <cname>Databázové systémy</cname>

    <code>X36DBS</code>

    <semester>Zima 2006, lichý týden</semester>

    <seminar>Čtvrtek 7.30</seminar>
  </course>

  <author>
    <aname>Zbyněk Lstibůrek</aname>

    <uname>lstiburz1</uname>

    <email>lstibuz1@fel.cvut.cz</email>
  </author>

  <content>
    <declaration>Prohlašuji, že jsem svou semestrální práci vypracoval
    samostatně. Všechny zdroje, ze kterých jsem čerpal, jsou uvedeny v části
    Odkazy.</declaration>

    <title>Pěvecký sbor (ukázková semestrálka a komentáře)</title>

    <description>
      <title>Popis</title>

      <para>Pěvecký sbor je skupina lidí, která se víceméně pravidelně schází
      na zkouškách, kde nacvičuje hudební skladby, jež pak provádí na
      koncertech v různých místech. Databázový systém slouží k evidenci
      členské základny, zapůjčených not a koncertních šatů, informací o konání
      a programu zkoušek a koncertů a také podrobných údajů o skladbách v
      repertoáru – pro zjednodušení práce při tisku koncertních
      programů.</para>

      <comment>
        <para>K O M E N T Á Ř E 

Tohle je komentář k 1. odstavci popisu semestrální práce.
           Zachovává formátování.

Zobrazení komentářů si můžete VYPNOUT 
   - v menu XML Mind Editoru View -&gt;   Hide comments
   - při html zobrazení tlačítkem "Vypnout/zaptnout zobrazeni komentaru" přímo na html stránce.

Komentář můžete používat k vlastním poznámkám k částem práce, 
dále jej může využít váš cvičící k tomu, aby připojil svoje hodnocení
k jednotlivým částem práce.

Komentovat lze samostatně:
           jednotlivé odstavce textů v částech Popis, Datové schéma, Skripty, Závěr, Odkazy 
           obrázek datového schématu
           popis SQL příkazu
           formulaci v relační algebře
           jednotlivé SQL příkazy
           tabulku pokrytí kategorií SQL příkazů.

Další informace o semestrální práci, struktuře, požadavcích a termínech jsou uvedeny 
formou komentářů přímo v tomto dokumentu.</para>
      </comment>

      <para>Zpěváci se dělí podle své zpěvní polohy (typicky soprán, alt,
      tenor, bas) do hlasových skupin, z nichž každá má určeného svého
      vedoucího. Skupiny mohou mít např. samostatné (dělené) zkoušky vedené
      právě vedoucím hlasu.</para>

      <comment>
        <para>S T R U K T U R A    S E M E S T R Á L N Í    P R Á C E  
Semestrálka má tyto části: 
            - hlavička (údaje o vás a o čase cvičení, prohlášení o autorství, název práce)
            - popis - stručná charakteristika vašeho projektu (několik odstavců, kde popíšete 
                           "realitu", kterou budete ve vaší semestrálce databázově modelovat
            - datové schéma (skládá se z obrázku (nejlépe formát png) a diskuse
                       obrázek je vytvořen nějakým nástrojem pro konceptuální datové modelování 
                                  (doporučený je ER Modelář, ale po dohodě se cvičícím můžete použít jiný).
                        Diskuse k datovému schématu zahrnuje
                                  výčet integritních omezení, které nebylo možné zahrnout do obrázku (jsou-li)
                                  diskuse ke každé smyčce, která se vyskytne ve vašem schématu
            - SQL příkazy  a příkazy v relační algebře - vypracujete:
                     alespoň 25 SQL příkazů nad vaší databází (tak aby pokryly kategorie v níže uvedené tabulce)
                     alespoň 10 z nich (jen dotazy) formulujete také v relační algebře
            - tabulka pokrytí požadovaných kategorií vašimi SQL příkazy 
            - skripty se zdrojjovými texty vašeho řešení:
                     - zdrojový soubor pro datové schéma
                     - SQL skripty pro vytvoření vaší databáze (ER modelář ho pro vás vygeneruje)
                     - SQL skript pro vložení testovacích dat do vaší databáze
                     - SQL skript s odladěnými příkazy
                     - log soubor (nasnímaný výstup), kterým doložíte, že vaše SQL příkazy jsou funkční
                        a vrací správná data
            - závěrečnou diskusi
            - odkazy na použité zdroje

  Všechny části semestrální práce jsou povinné.</para>
      </comment>

      <para>Protože noty jsou velmi drahé (předpokládá se neporušování
      autorského práva kopírováním:-), vede sbor přesnou evidenci o tom, kdo
      má u sebe který výtisk. Noty mohou mít buď podobu partů (vždy jen s
      notami určitého hlasu), nebo partitury (ta obsahuje všechny hlasy). V
      případě partů to znamená, že různí zpěváci mohou zpívat stejnou skladbu
      z jiných not. Dále existují zpěvníky nebo sborníky, které obsahují větší
      počet skladeb, někdy od různých autorů.</para>

      <comment>
        <para>T E C H N O L O G I E         A        N Á S T R O J E   

Semestrální práci odevzdáte ve formě XML dokumentu, který nahrajete do vašeho projektového adresáře na
serveru service.felk.cvut.cz. Do tohoto adresáře umístíte také všechny zdrojové souboru a obrázek datového schématu.


UMÍSTĚNÍ PRÁCE:
          http://service.felk.cvut.cz/courses/X36DBS/prj/&lt;vase_uzivatelske_jmeno&gt; nebo 
          http://service.felk.cvut.cz/courses/Y36DBS/prj/&lt;vase_uzivatelske_jmeno&gt; 
   technologie přístupu do této lokace je WebDAV, návody a nástroje naleznete na:
            <link url="http://service.felk.cvut.cz/pubguide/">http://service.felk.cvut.cz/pubguide/</link>

STRUKTURA DOKUMENTU:
Odevzdaná práce (XML dokument) nechť je validní dle specifikace sprojekt. Na adrese:
   <link url="http://service.felk.cvut.cz/courses/X36DBS/xml/sprojekt/">http://service.felk.cvut.cz/courses/X36DBS/xml/sprojekt/</link>
 najdete specifikace ve formátu DTD, XML Schema, Relax NG (sprojekt.dtd, sprojekt.xsd, sprojekt.png).
Pro editaci práce tedy lze použít libovolný XML editor.
Kompletní podpora pro formátování semestrálky (šablony a ukázkové semestrálky) 
pro kompletní offline práci je:
<link url="http://service.felk.cvut.cz/courses/X36DBS/xml/sprojekt.zip">http://service.felk.cvut.cz/courses/X36DBS/xml/sprojekt.zip</link>

TVORBA DOKUMENTU (semestrálky)
Pokud použijete jiný editor než XML Mind (viz níže), doporučuji stáhnout si šablonu pro semestrálku z DBS,
tu otevřít a vyplnit vlastním textem vaší semestrální práce.
 <link url="http://service.felk.cvut.cz/courses/X36DBS/xml/sprojekt/templates/dbs_semestral_work_template.xml">http://service.felk.cvut.cz/courses/X36DBS/xml/sprojekt/templates/dbs_semestral_work_template.xml</link>
Pokud toto neuděláte, pak je třeba, aby váš nově vytvořený dokument odkazoval na formátovací šablonu 
pro zobrazení v html podobě. Za specifikaci kódování v XML souboru:
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
je třeba umístit tuto instrukci pro provedení:
&lt;?xml-stylesheet type="text/xsl" href="http://service.felk.cvut.cz/courses/Y36DBS/xml/sprojekt_html.xsl"?&gt;


EDITOR XML MIND - DOPORUČUJI PRO TVORBU SEMESTRÁLKY
Home Edition tohoto nástroje je volně ke stažení pro platformy linux i windows:
<link url="http://www.xmlmind.com/xmleditor/download.shtml">http://www.xmlmind.com/xmleditor/download.shtml</link>
Až si ho stáhnete a nainstalujete a spustíte, doinstalujte si podporu dokumentu sprojekt (tvorba semestrálky):

Instalace balíku "sprojekt" (šablony pro semestrálku z DBS) v XML Mind
 Options -&gt; Preferences... -&gt; Install add-ons
           do okna "Download add-ons from this servers"
               přidat adresu: 
         http://service.felk.cvut.cz/courses/X36DBS/xml/sprojekt.xxe_addon
 Options -&gt; Install Add-ons...
      Načtou se informace o balících, tam najdete balík "DBS Semestralni prace"

Po dokončení instalace je třeba XML Mind restartovat. 
Po dalším spuštění se vám přes volbu File -&gt; New... v nabídce existujících formátů objeví nabídka:
 DBS Semestral Work Documentation 
a vy si můžete vybrat, zda si otevřete šablonu kam doplníte vlastní text semestrálky 
(A Template For Semestral Work With Comments) nebo vzorovou semestrálku s komentáři 
(Sample of Semestral Work), což přesně tento dokument.</para>
      </comment>

      <para>Každá skladba může mít jednoho skladatele (nemusí, může jít třeba
      o lidovou píseň, ani anonymních skladeb není málo) a – zejména v případě
      lidových písní – i autora úpravy. Rozumí se, že úpravu skladeb provádějí
      hudební skladatelé, takže každý skladatel v databázi nemusí být nutně
      autorem nějaké skladby. Větší skladby se mohou dělit na několik částí,
      jejich názvy bývá zvykem uvádět v koncertním programu.</para>

      <comment>
        <para>T E R M Í N Y      O D E V Z D Á N Í     -    K O N T R O L N Í     B O D Y

Váš cvičící s vámi na začátku semestru domluví přesné termíny 2 kontrolních bodů (a písemky.) 
To znamená deadline pro odevzdání části vaší semestrálky. 
Nedodržení deadline bude potrestáno stržením 5 bodů z počtu, který můžete za semestrálku získat (20).


1. Kontrolní bod
   - doporučovaný termín (garantem předmětu) 3. - 4. cvičení u počítačů
   - kontroluje se:
           - hlavička semestrálky
           - popis
           - datové schéma (včetně diskuse smyček)

2. kontrolní bod
     - doporučovaný termín (garantem předmětu) zápočtový týden
     - kontrolují se zbylé části dokumentace, tedy:
            - SQL příkazy
            - tabulka pokrytí kategorií SQL příkazů
            - skripty se zdrojovými texty (včetně LOG souboru s naskenovanými výsledky SQL příkazů)</para>
      </comment>

      <para>Pokud jde o sborové zkoušky, bylo uvedeno, že některé mohou být
      dělené, tj. některých zkoušek se nemusí účastnit všichni. U každé
      zkoušky je ale dán seznam těch, kteří na ní mají být, a na základě toho
      se eviduje docházka. Pro účast na koncertech platí stejný princip. U
      koncertů se sleduje také (hrubá) divácká účast a výše vybraného
      vstupného – kvůli různým statistikám.</para>

      <comment>
        <para>Z O B R A Z E N Í     S E M E S T R Á L K Y    N A    W W W

Pokud dodržíte výše uvedený postup, pak vám stačí do vašeho adresáře
na webis umístit (v závorce jsou uvedené soubory z tohoto příkladu):
     xml soubor se semestrálkou (test.xml)
     obrázek datového schématu  (pevecky_sbor.png)
     SQL skripty (create.sql, data.sql, query.sql, output.log)

Jak to bude vypadat ve výsledku se můžete podívat zde (cože je :
<link url="http://service.felk.cvut.cz/courses/X36DBS/xml/test/test.xml">http://service.felk.cvut.cz/courses/X36DBS/xml/test/test.xml</link>

Motivace pro použití této technologie:
1. zamezení různým nedorozuměním v tom, co má obsahovat vaše semestrálka
2. věřím tomu, že až zvládnete práci s nějakým XML editorem, bude to pro vás výrazné 
    zjednodušení (nemusíte se vůbec zabývat grafickou stránkou semestrálky) ,
3. vyrobením semestrálky v XML nám poskytnete vhodná data pro experimenty, které provádíme
    v rámci projektu CellStore - implemetnace XML-nativního databázového stroje
    <link url="http://cellstore.felk.cvut.cz">http://cellstore.felk.cvut.cz</link>
    Na tomto projektu se podílí rovněž studenti (mimo jiné byl zdrojem několika velmi pěkných
    a již úspěšně obhájených bakalářských a diplomových prací).


Zobrazení semestrálky v XML na WWW bylo úspěšně otestováno na prohlížečích FireFox 2 a 
Internet Explorer 7. Nefunguje například v prohlížeči Konquerror.

Máte-li nějaké (pádné ;-)  ) důvody k tomu, že nemůžete semestrálku odevzdat formou XML, 
řešte to, prosím, individuálně se svými cvičícími.</para>
      </comment>
    </description>

    <data_model>
      <title>datové schéma</title>

      <dm_picture>
        <mediaobject>
          <imageobject>
            <imagedata fileref="pevecky_sbor.png" />
          </imageobject>
        </mediaobject>
      </dm_picture>

      <comment>
        <para>Datové schéma vaší semestrálky by mělo být zhruba takto rozsáhlé. Je žádoucí, abyste si při návrhu vyzkoušeli
pokud možno všechny konstrukty ER modelu:

      silná entita
      slabá entita (potažmo vztahová entita)
      vztahy s různými kardinalitami (1-1, 1-N, M-N) a parcialitami (povinná, nepovinná účast entity ve vztahu),
      ISA hierarchie (pozor, tady je to výrazně jiné, než jste zvyklí z OOP)

Element imagedata, který reprezentuje obrázek, má atribut fileref, kam musíte napsat jméno obrázku.

Někteří z vás časem postoupí do magisterského studijního programu a  zapíší si předmět "Jazyk SQL". 
Tam budete mít také vypracovat semestrální práci. V zadání vám bude uloženo, abyste navázali na výsledek této semestrálky. 
Nezapomeňte si její dokumentaci pečlivě uložit. Ušetříte tím potom hodně práce.
I tento argument mluví pro to, abyste své schéma navrhli dostatečně rozsáhlé. I výše zmíněné smyčky se vám budou hodin.</para>
      </comment>

      <dm_discussion>
        <para>Moje schéma obsahuje smyčku Zpěvák – Příslušnost – Hlas – Vedení
        – Zpěvák. Toto je ovšem v pořádku, protože mezi entitami HLAS a ZPEVAK
        existují dva nezávislé vztahy. Vztahy "je členem" a "je vedoucím"
        nejsou vzájemně nijak ovlivňovány. Vedoucím hlasové skupiny bude v
        drtivé většině případů některý z jeho členů, ale může jím být i někdo
        "zvenku", kdo je ale také registrován jako zpěvák. Jiné řešení kdy,
        bych např. zavedl atribut "je_vedouci" u vztahu Příslušnost, by
        pokrývalo požadavek, že vedoucím skupiny typu HLAS může být pouze
        příslušník skupiny, ale nebylo by možné datově zajistit pravidlo, že
        skupina může mít jednoho vedoucího. Možným řešením této problematiky
        by bylo i přidání atributu "vedoucí" k typu Hlas, který by mohl
        nabývat jakékoliv (i prázdné) hodnoty nepodléhající žádnému omezení
        (žádné kontrole).</para>

        <comment>
          <para>Tohle je komentář k 1. odstavci diskuse datového schématu.
            Komentář může mít více řádků.
                           Zachovává formátování.</para>
        </comment>

        <para>ZPEVAK-UCAST-UDALOST-CAST_PROGRAMU_SKADBA-ZARAZENI-PUBLIKACE-VYTISK-ZAPUJCKA_NOT.
        Interpretace této smyčky z hlediska entity zpěvák je taková, že zpěvák
        může mít půjčeny noty na skladbu, která se nehraje na žádné zkoušce
        nebo koncertě, kterých by se zúčastnil. V "praktickém" životě je
        taková situace běžná (řekněme, že si noty oné skladby vypůjčil z
        jiného důvodu).</para>
      </dm_discussion>
    </data_model>

    <queries>
      <title>Dotazy</title>

      <dotazy>
        <dotaz>
          <popis_dotazu>
            <para>Seznam koncertů, na nichž bylo více než 100 diváků</para>
          </popis_dotazu>

          <comment>
            <para>Komentář k popisu dotazu.</para>
          </comment>

          <relacni_algebra>Koncert(divaku &gt; 100)</relacni_algebra>

          <comment>
            <para>Komentář k relační algebře.</para>
          </comment>

          <sql>SELECT * 
FROM Koncert
WHERE divaku &gt; 100;</sql>

          <comment>
            <para>Komentář k SQL dotazu.</para>
          </comment>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Seznam zpěváků, jejichž vedoucím je Alena Havlíková.</para>
          </popis_dotazu>

          <relacni_algebra>A := {Hlas * Vedeni * Zpevak(jmeno='Alena' and prijmeni='Havlíková')}[zkratka]
Vysledek := Zpevak &lt;hlas = zkratka] A</relacni_algebra>

          <sql>
SELECT Zpevak.* 
FROM Zpevak JOIN (
         SELECT zkratka FROM Vedeni NATURAL JOIN Zpevak
         WHERE jmeno='Alena' AND prijmeni='Havlíková'
         ) ON hlas=zkratka;</sql>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Stejné zadání jako předchozí, nyní s poddotazem v klauzuli
            WHERE.</para>
          </popis_dotazu>

          <sql>SELECT * 
FROM Zpevak 
WHERE hlas = (
    SELECT zkratka FROM Vedeni NATURAL JOIN Zpevak
    WHERE jmeno='Alena' AND prijmeni='Havlíková'
    );</sql>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Názvy všech skladeb A. Dvořáka v repertoáru.</para>
          </popis_dotazu>

          <relacni_algebra>{Skladatel(jmeno='Antonín' and prijmeni='Dvořák') * 
   Autorstvi * Skladba}[nazev] </relacni_algebra>

          <sql>SELECT nazev 
FROM Skladba NATURAL JOIN Autorstvi NATURAL JOIN Skladatel
WHERE jmeno='Antonín' AND prijmeni='Dvořák'; </sql>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Seznam zpěváků, kteří nemají zapůjčeny šaty.</para>
          </popis_dotazu>

          <relacni_algebra>Zpevak \ {Zpevak &lt;* Zapujcka_satu} </relacni_algebra>

          <sql>SELECT * FROM Zpevak 
MINUS
SELECT Zpevak.* 
    FROM Zpevak JOIN Zapujcka_satu
         ON Zpevak.RC = Zapujcka_satu.RC;</sql>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Stejné zadání jako předchozí, řešení pomocí
            poddotazu.</para>
          </popis_dotazu>

          <sql>SELECT * 
FROM Zpevak
WHERE RC NOT IN (SELECT RC FROM Zapujcka_satu); </sql>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Seznam dosud neprovedených skladeb (nebyly na programu
            žádného koncertu), včetně autorů.</para>
          </popis_dotazu>

          <relacni_algebra>A := Skladba[id, nazev] \ {Skladba &lt;* {Cast_programu * Koncert}}[id, nazev]
Vysledek := {A *_L Autorstvi}[jmeno, prijmeni, nazev]</relacni_algebra>

          <sql>SELECT jmeno, prijmeni, nazev
FROM (
        SELECT id, nazev FROM Skladba
        MINUS
        SELECT id, nazev FROM Skladba
        NATURAL JOIN Cast_programu NATURAL JOIN Koncert
       ) LEFT JOIN Autorstvi USING (id)
         LEFT JOIN Skladatel USING(jmeno, prijmeni);
</sql>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Seznam vícedílných skladeb.</para>
          </popis_dotazu>

          <relacni_algebra>Skladba &lt;* Cast_skladby</relacni_algebra>

          <sql>SELECT jmeno, prijmeni, nazev
FROM (SELECT * FROM Skladba WHERE id IN (SELECT id FROM Cast_skladby)
      )LEFT JOIN Autorstvi USING (id)
       LEFT JOIN Skladatel USING(jmeno, prijmeni); </sql>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Program koncertu 18. 1. 2005.</para>
          </popis_dotazu>

          <relacni_algebra>{Skladba * Cast_programu * Koncert(cas='18.01.2005')}[id, nazev] </relacni_algebra>

          <sql>ALTER Session SET NLS_DATE_FORMAT='DD.MM.YYYY';
SELECT jmeno, prijmeni, nazev 
FROM Skladatel 
     JOIN Autorstvi using (jmeno, prijmeni)
     JOIN Skladba using (id)
     JOIN Cast_programu using (id)
     JOIN Koncert using (misto, cas)
WHERE TRUNC(cas)=TRUNC(TO_DATE('18.01.2005')); 
</sql>

          <comment>
            <para>Schválně si můžete vyzkoušet, že, když dotaz změníte takto:
SELECT jmeno, prijmeni, nazev 
FROM Skladatel 
     NATURAL JOIN Autorstvi
     NATURAL JOIN Skladba
     NATURAL JOIN Cast_programu
     NATURAL JOIN Koncert
WHERE TRUNC(cas)=TRUNC(TO_DATE('18.01.2005')); 
Dostanete ve výsledku místo 7 řádků (správná odpověď) řádků 3528.

 Proč je tomu tak?

Celá záležitost se pokazí projekcí, pokud v klauzuli SELECT necháte *, je výsledek stále ještě správný.

Pokud bychom tedy trvali na použití NATURAL JOIN, lze dotaz formulovat takto:

Select jmeno, prijmeni, nazev
from 
  (select * 
  from  skladatel 
      natural join autorstvi 
      natural join skladba 
      natural join cast_programu
      natural join koncert
  WHERE TRUNC(cas)=TRUNC(TO_DATE('18.01.2005'))
  );

Oracle má zjevně v tomto kontextu problém, ale pouze tehdy, když pomocí NATURAL JOIN
spojujeme více než 3 tabulky. Například dotaz 7 funguje správně.
Ať to budeme nazývat "bug" nebo "feature", je třeba s tímto fenoménem počítat!!!</para>
          </comment>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Seznam zpěváků se 100% docházkou.</para>
          </popis_dotazu>

          <relacni_algebra>Zpevak &lt;* {Ucast[RC] \ Ucast(pritomen=0)[RC]} </relacni_algebra>

          <sql>SELECT Zpevak.* 
FROM Zpevak JOIN (
         SELECT DISTINCT RC FROM Ucast
         MINUS
         SELECT DISTINCT RC FROM Ucast WHERE pritomen=0
          ) Vzorni ON Zpevak.RC=Vzorni.RC; </sql>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Stejný dotaz jako předchozí, tentokrát řešený
            poddotazem.</para>
          </popis_dotazu>

          <sql>SELECT * 
FROM Zpevak 
WHERE RC NOT IN (
     SELECT RC FROM Ucast WHERE pritomen=0
      );</sql>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Opět stejný dotaz řešený vztaženým poddotazem.</para>
          </popis_dotazu>

          <sql>SELECT * 
FROM Zpevak 
WHERE NOT EXISTS (
        SELECT * FROM Ucast WHERE pritomen=0 AND Ucast.RC=Zpevak.RC
         );</sql>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Seznam zpěváků, kteří nemají noty na Čtyři písně o
            Marii.</para>
          </popis_dotazu>

          <relacni_algebra>Zpevak \ {Zpevak &lt;* {Zapujcka_not * Publikace * Zarazeni 
  * Skladba(nazev='Čtyři písně o Marii')}}</relacni_algebra>

          <sql>SELECT jmeno, prijmeni FROM Zpevak
 MINUS
SELECT jmeno, prijmeni FROM Zpevak
     JOIN Zapujcka_not using (RC)
     JOIN Publikace using (kat_cislo)
     JOIN Zarazeni using (kat_cislo)
     JOIN Skladba using (id)
WHERE nazev='Čtyři písně o Marii'; </sql>

          <comment>
            <para>Proč ne NATURAL JOIN?  Viz diskuse u dotazu 9.</para>
          </comment>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Skladatelé, kteří jsou autorem nějaké skladby a zároveň
            upravovatelem nějaké skladby.</para>
          </popis_dotazu>

          <relacni_algebra>{Skladatel &lt;* Autorstvi(je_uprava=0)} ∩ {Skladatel &lt;* Autorstvi(je_uprava&lt;&gt;0)} </relacni_algebra>

          <sql>SELECT jmeno, prijmeni FROM Skladatel JOIN Autorstvi using (jmeno, prijmeni) WHERE je_uprava=0
 INTERSECT
SELECT jmeno, prijmeni FROM Skladatel JOIN Autorstvi using (jmeno, prijmeni) WHERE je_uprava&lt;&gt;0;
</sql>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Seznam publikací, od kterých je v inventáři méně než pět
            exemplářů. První realizaci můžeme zjednodušit tak, vybereme ty
            publikace, kde existují jen exempláře s pořadovými čísly &lt;
            5.</para>
          </popis_dotazu>

          <relacni_algebra>Publikace \ {Publikace * Vytisk}(cislo_exemplare &gt;=5)[Publikace.*]</relacni_algebra>

          <sql>SELECT * 
FROM Publikace A 
WHERE NOT EXISTS (
      SELECT * FROM Vytisk
      WHERE A.kat_cislo=Vytisk.kat_cislo AND cislo_exemplare &gt;= 5);</sql>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Stejný dotaz s použitím agregace, navíc bez výše použitého
            zjednodušeni.</para>
          </popis_dotazu>

          <sql>SELECT * 
FROM Publikace
WHERE 5 &gt; (SELECT COUNT(*) FROM Vytisk
            WHERE Publikace.kat_cislo=Vytisk.kat_cislo);</sql>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Seznam publikací, které obsahují více než jednu
            skladbu.</para>
          </popis_dotazu>

          <relacni_algebra>Publikace &lt;* 
  {Zarazeni[kat_cislo=k_c AND id &lt; id_d]Zarazeni&lt;kat_cislo -&gt; k_c, id -&gt; id_d&gt;} </relacni_algebra>

          <sql>SELECT * 
FROM Publikace NATURAL JOIN (
      SELECT DISTINCT A.kat_cislo 
      FROM Zarazeni A JOIN Zarazeni B 
           ON A.kat_cislo=B.kat_cislo AND A.id &lt; B.id
);</sql>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Stejný dotaz přehledněji s agregací.</para>
          </popis_dotazu>

          <sql>SELECT * 
FROM Publikace 
WHERE 1 &lt; (
            SELECT COUNT(*) FROM Zarazeni
            WHERE Zarazeni.kat_cislo=Publikace.kat_cislo
      ); </sql>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Seznam zpěváků, kteří nikdy nezpívali žádnou skladbu Jana
            Hanuše.</para>
          </popis_dotazu>

          <relacni_algebra>  -- Všechny události, kde se zpívala nějaká skladba Jana Hanuše:
  A := {Skladatel(jmeno='Jan' and prijmeni='Hanuš') 
      * Autorstvi * Skladba * Cast_programu * Udalost}[misto, cas]
  -- Seznam zpěváků, kteří byli na některé z těchto událostí:
  B := {A * Ucast(pritomen&lt;&gt;0)}[RC] 
Vysl := Zpevak \ {Zpevak * B} </relacni_algebra>

          <sql>SELECT jmeno, prijmeni 
FROM Zpevak 
WHERE RC NOT IN (
      SELECT RC FROM Ucast 
      WHERE (misto, cas) IN (
         SELECT misto, cas
         FROM Skladatel
              JOIN Autorstvi using (jmeno, prijmeni)
              JOIN Skladba using (id)
              JOIN Cast_programu using (id)
              JOIN Udalost using (misto, cas)
         WHERE jmeno='Jan' AND prijmeni LIKE 'Hanuš'
         )
      AND pritomen &lt;&gt; 0
      );</sql>

          <comment>
            <para>Proč ne NATURAL JOIN? Viz diskuse u dotazu 9.</para>
          </comment>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Seznam všech koncertů a generálek.</para>
          </popis_dotazu>

          <relacni_algebra>{Koncert[cas, misto] x {('Koncert')}} 
 ∪ {Zkouska(je_generalka)[cas, misto] x {('Generálka')}} </relacni_algebra>

          <sql>SELECT cas, misto, 'Koncert' AS druh FROM Koncert
 UNION
SELECT cas, misto, 'Generálka' AS druh FROM Zkouska WHERE je_generalka&lt;&gt;0
ORDER BY cas;</sql>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Seznam koncertů, na nichž byly provedeny všechny skladby B.
            Martinů na repertoáru.</para>
          </popis_dotazu>

          <relacni_algebra>  -- ID všech skladeb B. Martinů:
 SkladbyBM := {Skladatel(jmeno='Bohuslav' and prijmeni='Martinů') 
               * Autorstvi * Skladba}[id]
  -- Všechny kombinace koncert-skladba B. Martinů:
  VseKomb := SkladbyBM x Koncert[misto, cas]
  -- Všechny neuskutečněné kombinace:
  Nerealne := VseKomb \ Cast_programu[id, misto, cas]
  -- Koncerty, na nichž chyběla nějaká skladba B. Martinů:
  Neuplne := Koncert &lt;* Nerealne

Vysl := Koncert \ Neuplne </relacni_algebra>

          <sql>SELECT misto, cas FROM Koncert
 MINUS
SELECT misto, cas 
FROM (SELECT id FROM Skladatel
           JOIN Autorstvi using (jmeno, prijmeni)
           JOIN Skladba using (id)
      WHERE jmeno='Bohuslav' AND prijmeni='Martinů'
      ) CROSS JOIN Koncert
WHERE (id, misto, cas) NOT IN (SELECT id, misto, cas
                               FROM Cast_programu); </sql>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Který zpěvák má největší z půjčených šatů?</para>
          </popis_dotazu>

          <sql>SELECT jmeno, prijmeni, velikost 
FROM Zpevak
     JOIN Zapujcka_satu using (RC)
     JOIN Saty using (inv_cislo)
WHERE velikost=(SELECT MAX(velikost) FROM Saty NATURAL JOIN Zapujcka_satu); </sql>

          <comment>
            <para>Proč ne NATURAL JOIN?  Viz diskuse u dotazu 9.</para>
          </comment>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Přehled účasti na zkouškách (v procentech).</para>
          </popis_dotazu>

          <sql>SELECT jmeno, prijmeni, 
   CAST((SELECT COUNT(*) FROM Ucast NATURAL JOIN Zkouska
         WHERE Zpevak.RC=Ucast.RC AND pritomen&lt;&gt;0)
         AS REAL)
        /(SELECT COUNT(*) FROM Ucast NATURAL JOIN Zkouska
          WHERE Zpevak.RC=Ucast.RC
        )*100 || ' %' AS dochazka
FROM Zpevak ORDER BY prijmeni; </sql>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Seznam hlasových skupin: název, počet členů, jméno
            vedoucího.</para>
          </popis_dotazu>

          <sql>SELECT  nazev_h,
  poc_clenu,
  jmeno || ' ' || prijmeni AS vedouci
FROM (
      SELECT zkratka, nazev_h, COUNT(RC) AS poc_clenu
      FROM Hlas LEFT JOIN Zpevak ON Hlas.zkratka=Zpevak.hlas
      GROUP BY zkratka, nazev_h
     )
     LEFT JOIN Vedeni USING(zkratka) LEFT JOIN Zpevak USING(RC); </sql>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Seznam míst, na kterých se koncertovalo vícekrát a vždy bylo
            přítomno více než 50 diváků.</para>
          </popis_dotazu>

          <sql>SELECT misto, count(misto) AS pocet_koncertu, AVG(divaku) AS prum_divaku
FROM Koncert
WHERE divaku &gt; 50 
GROUP BY misto
HAVING count(misto) &gt; 1; </sql>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Skladatel nejvíce zastoupený na koncertech co do počtu
            skladeb.</para>
          </popis_dotazu>

          <sql>--Využívám pohled rating_skladatelu:
SELECT jmeno, prijmeni, pocet 
FROM Rating_skladatelu
WHERE pocet = (SELECT MAX(pocet) FROM Rating_skladatelu); </sql>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Pro divácky nejúspěšnější koncert určit rozdíl ceny
            vstupného od průměru.</para>
          </popis_dotazu>

          <sql> SELECT (
        SELECT vstupne FROM Koncert
            WHERE divaku = (
                            SELECT max(divaku) FROM Koncert
                           )
       ) - (
        SELECT AVG(vstupne) FROM Koncert
       )
AS odchylka FROM Dual;
</sql>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Skladatelé, kteří se mohli během života setkat s Bohuslavem
            Martinů.</para>
          </popis_dotazu>

          <sql>SELECT * FROM skladatel
 WHERE rok_narozeni &lt; (SELECT rok_umrti FROM skladatel
                       WHERE jmeno='Bohuslav' AND prijmeni='Martinů')
       AND rok_umrti &gt; (SELECT rok_narozeni FROM skladatel
                        WHERE jmeno='Bohuslav' AND prijmeni='Martinů');</sql>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Seznam skladatelů, jejichž skladby byly na programu koncertů
            s nadprůměrnou návštěvou.</para>
          </popis_dotazu>

          <sql>SELECT DISTINCT jmeno, prijmeni 
FROM skladatel
   JOIN autorstvi using (jmeno, prijmeni)
   JOIN skladba using (id)
   JOIN cast_programu using (id)
   JOIN koncert using (misto, cas)
WHERE divaku &gt; (SELECT AVG(divaku) FROM koncert); </sql>

          <comment>
            <para>Proč ne NATURAL JOIN? Viz diskuse u dotazu 9.</para>
          </comment>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Koncert, na němž bylo uvedeno nejvíce různých
            skladeb.</para>
          </popis_dotazu>

          <sql>SELECT * 
FROM (
   SELECT misto, cas, COUNT(*) AS pocet 
   FROM cast_programu NATURAL JOIN koncert 
   GROUP BY misto, cas
      ) WHERE pocet = (
          SELECT MAX(pocet) FROM (
               SELECT COUNT(*) AS pocet
               FROM cast_programu NATURAL JOIN koncert 
               GROUP BY misto, cas
              )
     ); </sql>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Přehled ošacení - všichni zpěváci a jejich šaty, zároveň
            všechny šaty a jejich držitelé.</para>
          </popis_dotazu>

          <sql>SELECT
    COALESCE(prijmeni, 'VOLNÉ') AS drzitel,
    inv_cislo, velikost
FROM Zpevak LEFT JOIN Zapujcka_satu USING(RC)
     FULL JOIN Saty USING(inv_cislo); </sql>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Skladatelé a počet uvedení jejich skladeb</para>
          </popis_dotazu>

          <sql>CREATE OR REPLACE VIEW rating_skladatelu AS 
SELECT jmeno, prijmeni, count(*) AS pocet 
FROM Skladatel
      JOIN Autorstvi using (jmeno, prijmeni)
      JOIN Skladba using (id)
      JOIN Cast_programu using (id)
      JOIN Koncert using (misto, cas) 
GROUP BY jmeno, prijmeni;

select * from rating_skladatelu;</sql>

          <comment>
            <para>Všimněte si syntaxe - CREATE OR REPLACE, co to dělá je zřejmé - pokud pohled 
již existuje v datovém slovníku, je nahrazen novou definicí. 
Pokud by pohled existoval a vy zadali pouze CREATE VIEW, dostanete chybovou hlášku:
"ORA-00955: name is already used by an existing object"

Proč JOIN USING namísto NATURAL JOIN?  Viz poznámka u dotazu 9.</para>
          </comment>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Vytvoříme redundantní tabulku ucasti_zpevaku, kde budou
            předspočítané hodnoty. Tuto tabulku naplníme daty. Atribut koef
            vyjadřuje koeficient (ponechme stranou, co to znamená).</para>
          </popis_dotazu>

          <sql>drop table ucasti_zpevaku;

create table ucasti_zpevaku (
  rc number(10),
  jmeno varchar2(30),
  prijmeni varchar2(30),
  zkousek number(4),
  koncertu number(4),
  koef number(1));


insert into ucasti_zpevaku
  SELECT rc, jmeno, prijmeni, 
     (SELECT COUNT(*) FROM Ucast NATURAL JOIN Zkouska
           WHERE Zpevak.RC=Ucast.RC AND pritomen&lt;&gt;0)
            as zkousek, 
     (SELECT COUNT(*) FROM Ucast NATURAL JOIN Koncert
            WHERE Zpevak.RC=Ucast.RC AND pritomen&lt;&gt;0)
            as koncertu,
      0 as koef
  FROM Zpevak ORDER BY prijmeni;

commit;

select * from ucasti_zpevaku;</sql>

          <comment>
            <para>Příkaz DROP TABLE na začátku této sekvence je zde opět proto, že předpokládáme vícenásobné
spouštění skriptu dotazy.sql (viz skripty). Pokud bude odvozena tabulka ucasti_zpevaku již
existovat, opět bychom dostali hlášku:
"ORA-00955: name is already used by an existing object"
Nicméně příkaz CREATE TABLE nemá variantu CREATE OR REPLACE!!!

U testování DML příkazů (INSERT, UPDATE, DELETE) nezapomeňte transakci ukončit 
příkazem TCL (COMMIT - potvrzení změn nebo ROLLBACK - odvolání změn). 

Když to neuděláte, tak vám následné spuštění skriptu, případně DML nebo DDL příkaz nad
stejnou tabulkou zůstane viset. 

Z hlediska transakčního zpracování je to správné řešení - zdroje v té tabulce jsou dosud 
blokovány jinou transakcí!!!

Pokud se do této situace dostanete - může vám pomoci ukončení SQL klienta, ze kterého 
jste nepotvrzený (tedy nenásledovaný příkazem COMMIT či ROLLBACK) DML příkaz poslali.
Ale také to může systému chvíli trvat než se vzpamatuje, takže je lepší s tím počítat.

DDL příkazy (CREATE, ALTER, DROP) jsou "samo-potvrzovací" - před jejich provedením se
automaticky provede COMMIT a po jejich provedení rovněž.

Výše uvedené 3 příkazy můžeme v SQL spojit do jednoho:</para>
          </comment>

          <sql>drop table ucasti_zpevaku;

create table UCASTI_ZPEVAKU as
  SELECT rc, jmeno, prijmeni, 
     (SELECT COUNT(*) FROM Ucast NATURAL JOIN Zkouska
           WHERE Zpevak.RC=Ucast.RC AND pritomen&lt;&gt;0)
            as zkousek, 
     (SELECT COUNT(*) FROM Ucast NATURAL JOIN Koncert
            WHERE Zpevak.RC=Ucast.RC AND pritomen&lt;&gt;0)
            as koncertu,
      0 as koef
   FROM Zpevak ORDER BY prijmeni;

select * from ucasti_zpevaku;</sql>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Zpěvákům, kteří zpívají alt nastavíme v relaci
            ucasti_zpevaku hodnotu atributu koef tak, že vyjadřuje počet jimi
            zapůjčených výtisků not.</para>
          </popis_dotazu>

          <sql>update ucasti_zpevaku u
set koef = 
    (select count(*) 
     from zapujcka_not z 
     where u.rc = z.rc)
where u.rc in (select rc from zpevak where hlas = 'A');

commit;</sql>
        </dotaz>

        <dotaz>
          <popis_dotazu>
            <para>Z tabulky ucasti_zpevaku vymažeme ty zpěváky, kteří zpívají
            basy.</para>
          </popis_dotazu>

          <sql>delete from ucasti_zpevaku
where rc in (select rc from zpevak where hlas = 'B');

commit;</sql>
        </dotaz>
      </dotazy>

      <pokryti_dotazu>
        <kategorie_dotazu>
          <entry>A</entry>

          <entry>1, 4, 9</entry>

          <entry>jednoduché dotazy (SELECT ... FROM ... WHERE)</entry>
        </kategorie_dotazu>

        <kategorie_dotazu>
          <entry>B</entry>

          <entry>1, 3, 8, 9, 14, 15, 17, 20, 25, 28, 29</entry>

          <entry>Vyber všechny, pro něž platí, že...</entry>
        </kategorie_dotazu>

        <kategorie_dotazu>
          <entry>C</entry>

          <entry>5, 7, 13</entry>

          <entry>Vyber všechny, pro něž NEplatí, že...</entry>
        </kategorie_dotazu>

        <kategorie_dotazu>
          <entry>D</entry>

          <entry>10, 21</entry>

          <entry>Vyber ty, pro něž všechny...</entry>
        </kategorie_dotazu>

        <kategorie_dotazu>
          <entry>E</entry>

          <entry>19</entry>

          <entry>Vyber ty, pro něž žádné...</entry>
        </kategorie_dotazu>

        <kategorie_dotazu>
          <entry>F1</entry>

          <entry>2, 5, 17</entry>

          <entry>spojení - JOIN ON</entry>
        </kategorie_dotazu>

        <kategorie_dotazu>
          <entry>F2</entry>

          <entry>4, 7, 9, 13, 19, 29, 31</entry>

          <entry>spojení - NATURAL JOIN | JOIN USING</entry>
        </kategorie_dotazu>

        <kategorie_dotazu>
          <entry>F3</entry>

          <entry>21</entry>

          <entry>spojení - CROSS JOIN</entry>
        </kategorie_dotazu>

        <kategorie_dotazu>
          <entry>F4</entry>

          <entry>7, 8, 24, 31</entry>

          <entry>polospojení (vnější) - LEFT | RIGHT OUTER JOIN</entry>
        </kategorie_dotazu>

        <kategorie_dotazu>
          <entry>F5</entry>

          <entry>31</entry>

          <entry>plné (vnější) spojení - FULL (OUTER) JOIN</entry>
        </kategorie_dotazu>

        <kategorie_dotazu>
          <entry>G1</entry>

          <entry>3, 6, 8, 11, 15, 16, 18, 19, 21, 22, 28, 29, 30</entry>

          <entry>vnořený dotaz v klauzuli WHERE</entry>
        </kategorie_dotazu>

        <kategorie_dotazu>
          <entry>G2</entry>

          <entry>2, 7, 8, 10, 17, 21, 24, 30</entry>

          <entry>vnořený dotaz v klauzuli FROM</entry>
        </kategorie_dotazu>

        <kategorie_dotazu>
          <entry>G3</entry>

          <entry>23, 27</entry>

          <entry>vnořený dotaz v klauzuli SELECT</entry>
        </kategorie_dotazu>

        <kategorie_dotazu>
          <entry>G4</entry>

          <entry>12, 15, 16, 17</entry>

          <entry>vztažený vnořený dotaz (EXISTS | NOT EXISTS)</entry>
        </kategorie_dotazu>

        <kategorie_dotazu>
          <entry>H1</entry>

          <entry>20</entry>

          <entry>množinové sjednocení - UNION</entry>
        </kategorie_dotazu>

        <kategorie_dotazu>
          <entry>H2</entry>

          <entry>5, 7, 10, 13, 21</entry>

          <entry>množinový rozdíl - MINUS (v Oracle)</entry>
        </kategorie_dotazu>

        <kategorie_dotazu>
          <entry>H3</entry>

          <entry>14</entry>

          <entry>množinový průnik - INTERSECT</entry>
        </kategorie_dotazu>

        <kategorie_dotazu>
          <entry>I1</entry>

          <entry>16, 18, 22, 23, 24, 25, 26, 27, 29, 30</entry>

          <entry>agregační funkce (count | sum | min | max| avg)</entry>
        </kategorie_dotazu>

        <kategorie_dotazu>
          <entry>I2</entry>

          <entry>24, 25, 30I</entry>

          <entry>agregační funkce nad seskupenými řádky - GROUP BY
          (HAVING)</entry>
        </kategorie_dotazu>

        <kategorie_dotazu>
          <entry>J</entry>

          <entry>10+11+12</entry>

          <entry>stejný dotaz ve třech různých formulacích SQL</entry>
        </kategorie_dotazu>

        <kategorie_dotazu>
          <entry>K</entry>

          <entry>25</entry>

          <entry>všechny klauzule - SELECT FROM WHERE GROUP BY HAVING ORDER
          BY</entry>
        </kategorie_dotazu>

        <kategorie_dotazu>
          <entry>L</entry>

          <entry>32</entry>

          <entry>pohled VIEW</entry>
        </kategorie_dotazu>

        <kategorie_dotazu>
          <entry>M</entry>

          <entry>26</entry>

          <entry>dotaz nad pohledem</entry>
        </kategorie_dotazu>

        <kategorie_dotazu>
          <entry>L</entry>

          <entry>33</entry>

          <entry>INSERT .... SELECT příkaz</entry>
        </kategorie_dotazu>

        <kategorie_dotazu>
          <entry>M</entry>

          <entry>34</entry>

          <entry>UPDATE s vnořeným SELECT příkazem</entry>
        </kategorie_dotazu>

        <kategorie_dotazu>
          <entry>N</entry>

          <entry>35</entry>

          <entry>DELETE s vnořeným SELECT příkazem</entry>
        </kategorie_dotazu>
      </pokryti_dotazu>

      <comment>
        <para>V semestrálce se požaduje alespoň 10 dotazů v relační algebře a alespoň 25 SQL příkazů. 
SQL příkazů samozřejmě můžete mít více (jako v této semestrálce), je ale podstatné, abyste 
jimi pokryli všechny kategorie ve výše uvedené tabulce. 
Samozřejmě tedy jeden dotaz může pokrýt více kategorií.</para>
      </comment>
    </queries>

    <scripts>
      <title>Skripty</title>

      <para>Zdroj pro ER-modelář - <link
      url="pevecky_sbor.xml">pevecky_sbor.xml</link></para>

      <para>Skript pro vytvoření databáze - <link
      url="create.sql">create.sql</link> - vytvořený ER Modelářem, nicméně zde
      můžete udělat svoje úpravy. Samozřejmě je vhodné je komentovat.</para>

      <comment>
        <para>I v této sekci můžete komentovat jednotlivé odstavce.

Když vyrobíte uvnitř odstavce (para) entitu link, nezapomeňte, 
že je třeba u ní zadat též hodnotu atributu url.</para>
      </comment>

      <para>Skript pro vložení dat do databáze - <link
      url="data.sql">data.sql</link></para>

      <comment>
        <para>Vaše testovací data by měla být natolik rozsáhlá a tak navržená, abyste na nich mohli dobře ukázat,
že vámi navržené SQL příkazy fungují správně.
Insert příkazy můžete psát přímo v nějakém textovém editoru, ale můžete také své tabulky naplnit pomocí
formulářů v nástroji SQL Developer, který umožňuje exportovat data z tabulek ve formě INSERT příkazů.</para>
      </comment>

      <para>Skript s SQL dotazy, který je možné přímo spustit - <link
      url="dotazy.sql">dotazy.sql</link></para>

      <comment>
        <para>Pokud máte k dispozici nějaký xslt procesor, pak si výše uvedený skript můžete snadno vyrobit
ze zdrojového textu semestrálky pomocí formátovací šablony
 <link url="http://service.felk.cvut.cz/courses/X36DBS/xml/make_sql_queries_script.xsl">http://service.felk.cvut.cz/courses/X36DBS/xml/make_sql_queries_script.xsl</link>

Pokud nemáte k dispozici XSLT procesor, ale používáte Firefox (nebo Mozillu - tedy Sea Monkey, 
nebo jak se to vlastně teď jmenuje), pak lze použít tento postup:

1. Stáhněte si html dokument:
<link url="http://service.felk.cvut.cz/courses/X36DBS/xml/zobraz_dotazy.html">http://service.felk.cvut.cz/courses/X36DBS/xml/zobraz_dotazy.html</link>
    a umístěte ho do svého projektového adresáře na service.felk.cvut.cz.

2. Zdrojový text vaší semestrálky (umístěn tamtéž) nechť se jmenuje semestralka.xml 
    (jinak je třeba náležitě editovat soubor zobraz_dotazy.html, viz komentáře uvnitř)

3. Když nyní (ve FireFoxu nebo Mozille) necháte zobrazit soubor zobraz_dotazy.html (umístěný ve vašem
    projektovém adresáři), tak javascript vložený v této stránce provede XSLT transformaci, jejímž výsledkem
    bude stránka, ve které je výstupní skript dotazy.sql. Je uzavřený v elementu &lt;pre&gt; takže zachovává
    formátování. Stačí jej tedy přes schránku vložit do textového souboru dotazy.sql

Výsledek celého postupu aplikovaný na ukázkový soubor test.xml) je zde:
<link url="http://service.felk.cvut.cz/courses/X36DBS/xml/test/zobraz_dotazy_test.html">http://service.felk.cvut.cz/courses/X36DBS/xml/test/zobraz_dotazy_test.html</link>


Jednotlivé SQL příkazy budete zřejmě ladit v nástroji SQLDeveloper, protože je to nejpohodlnější.
Vřele však doporučuji použít řádkového klienta sqlplus (pro generování výstupu - viz dotazy.html) do vaší semestrálky.. 
Umožňuje totiž formátovat výstup přímo do html. Je to zařízeno pomocí příkazu 
SET MARKUP HTML a několika dalších příkazů SET, které nastavují prostředí SQL*Plus klienta:

set pagesize 1000
set echo on
set markup html on spool on head "
&lt;title&gt;X36DBS - Čtvrtek 7.30 - Zbyněk Lstibůrek - Výstup SQL příkazů &lt;/title&gt; 
&lt;style type ='text/css'&gt;&lt;!--body {background: #ffffc6} --&gt;&lt;/style&gt;" 
body "&lt;h2&gt;X36DBS - Čtvrtek 7.30 - Zbyněk Lstibůrek - Výstup SQL příkazů &lt;/h2&gt;"
spool dotazy.html

...... pak jsou samotné dotazy, s jejich slovním zadáním (komentář je uvozen pomocí --)

set markup html off
spool off

!!! A ještě pozor - v tomto komentáři jsem kvůli formátování rozdělil příkaz set markup thml on
na 4 řádky. Nicméně v souboru dotazy.sql, tohle neprojde !!!!


Spuštění souboru dotazy.sql v prostředí SQL*Plus klienta (na solarisech) vypadá takto
(předpokládám, že v aktuálním adresáři máte skript dotazy.sql, po skončení bude výstup v dotazy.html):

-bash-3.00$ sqlplus

SQL*Plus: Release 10.2.0.2.0 - Production on Mon Sep 24 11:26:50 2007

Copyright (c) 1982, 2005, Oracle.  All Rights Reserved.

Enter user-name: &lt;vaze_uživatelské_jméno&gt;
Enter password: &lt;vaše_heslo&gt;

Connected to:
Oracle Database 10g Enterprise Edition Release 10.2.0.2.0 - Production
With the Partitioning and Data Mining options

SQL&gt; @dotazy.sql
...... Teď se provádí dotazy, výstup jde na obrazovku a do souboru dotazy.html

SQL&gt; quit
Disconnected from Oracle Database 10g Enterprise Edition Release 10.2.0.2.0 - Production
With the Partitioning and Data Mining options
-bash-3.00$     


(Jak vidno, podstatným příkazem v SQL*Plus klientovi je "@jmeno</para>
      </comment>

      <para>Výstup předchozího skriptu - <link
      url="dotazy.html">dotazy.html</link>.</para>

      <comment>
        <para>Vyrobil jsem ho výše uvedeným postupem - tedy s použitím šablony, která ze zdrojového textu vaší semestrálky
vytáhne pouze SQL příkazy (a jejich slovní specifikaci, ze které udělá komentář) a obalí to řídícími příkazy
pro vytvoření HTML stránky. 
Vycházím z toho, že příkazy budete ladit jednotlivě (zřejmě v nástroji SQL Developer, kde to je velmi pohodlné).
Pro celkovou kontrolu je však mnohem lepší mít všechno pěkně v jednom dokumentu.</para>
      </comment>
    </scripts>

    <conclussions>
      <title>Závěr</title>

      <para>Úspěšně jsem vytvořil svůj první databázový projekt a osvojil jsem
      si základní metody databázového návrhu. Vzniklé databázi lze jistě
      vytknout řadu nedostatků. Ty pramení zejména z toho, že v době vytváření
      ER schématu jsem neměl jasnou představu o některých implementačních
      problémech souvisejících např. se spojováním tabulek. Kdybych navrhoval
      databázi znovu, asi bych nevolil za klíč řetězcové atributy, tím méně
      jejich dvojice. Také bych lépe rozložil atributy v ISA hierarchii
      Událost-Koncert-Zkouška, aby se např. místo konání nekopírovalo do všech
      instancí (to souvisí i s předchozí poznámkou o volbě klíčů). Protože
      jsem si tyto problémy začal naplno uvědomovat teprve v okamžiku, kdy
      jsem měl již hotová zkušební data a zabýval se dotazy, rozhodl jsem se
      schéma již neměnit a vyhnout se tak zavlečení nějakých dalších
      chyb.</para>

      <comment>
        <para>Stejně tak lze komentovat závěr.</para>
      </comment>
    </conclussions>

    <references>
      <title>Odkazy</title>

      <para>[1] Pokorný, Jaroslav, Halaška, Ivan, Databázové systémy, Praha
      1998</para>

      <comment>
        <para>A bude-li to třeba, můžete komentovat také odkazy.</para>
      </comment>

      <para>[2] Šimůnek, Milan, SQL, kompletní kapesní průvodce, Praha
      1997</para>
    </references>
  </content>
</sproject>